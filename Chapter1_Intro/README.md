Introduction
============

판다스는 파이썬의 데이터 분석 라이브러리로써 행과 열로 이루어진 테이블형태의 데이터를 관리하는데에 사용된다.

## 1. 판다스의 특징
----------------

* 데이터 그룹화
 특정 학과에서 A+성적을 받은 남/녀의 비율같은 테이블의 열을 그룹화하여 집계할 수 있다. 혹은 많은 데이터 프레임들을 하나로 통합하여 하나의 정보로 요약할 수도 있다.

* 데이터 분석 및 시각화
  데이터들을 간단하게 수치화할 수 있으며 이렇게 수치화된 데이터들을 차트같은 그래프로 시각화(Visualize)할 수 있다.
  또한 판다스의 데이터 프레임은 하나의 자료형만을 가지는데 이는 데이터 분석에 필요한 변수를 구성하는 기본 조건을 만족한다.

  데이터 분석에서의 변수분류 방법은 수치형(정수/실수), 텍스트형(문자형/범주형)이 있으며 수치형은 연속형(주어진 범위의 실수)과 정수형(정수값)을 구분하며 텍스트형에는 일반 텍스트와
  일정 범위를 가진 범주형으로 나뉘어진다.

## 2. 클래스
-----------

  판다스는 numpy 모듈을 기반으로 만들어졌기 때문에 numpy 기본연산을 모두 제공한다. 그러나 행과 열에 라벨링하여 내부 element들의 접근을 빠르게 만들었다는 것이 큰 차이이다.

* 연산자와 메소드
판다스에서 클래스를 만들 때에 numpy의 배열인 ndarray를 이용한다. 그렇기 때문에 판다스의 내부구조는 넘파이 모듈을 처리할 때와 일관성을 유지한다.

<img width="344" alt="1" src="https://user-images.githubusercontent.com/43739827/73640370-74be3680-46b1-11ea-9b01-305fe2b4caa3.png"></img>

Series는 1차원 벡터로 파이썬에서의 리스트를 입력하면 생성된다. 그러나 리스트와 다르게 Series에는 단일 자료형만 입력된다. 또한 레이블을 붙여 인덱스를 활용할 수 있으며
암묵적인 숫자 타입의 인덱스도 실행 가능하다.

위 실행결과와 같이 자료형을 지정하지 않을 때는 내부적으로 원소 값을 확인하여 추론해 가장 적절한 자료형을 선택한다.

<img width="243" alt="2" src="https://user-images.githubusercontent.com/43739827/73640757-31b09300-46b2-11ea-86c7-84dc9a00b14a.png"></img>

Series에 덧셈 연산자를 사용하면 계산된 결과값은 전혀 다른 Series로 반환된다. 이는 기존 Series값을 변경하지 않고
새로운 객체를 만들어서 반환하는 것이 판다스 모듈의 기본 원칙이기 때문이다.

<img width="244" alt="3" src="https://user-images.githubusercontent.com/43739827/73641052-b8fe0680-46b2-11ea-9856-bfbb631204b7.png"></img>

덧셈 연산자 이외에도 .add()메소드를 사용하면 동일한 결과를 출력할 수 있다.  

* 검색 및 슬라이싱  
판다스는 행과 열에 별도의 이름인 레이블을 추가할 수 있으며 이를 이용해 검색과 슬라이싱을 할 수 있다.
또한 판다스는 행과 열에 대한 다양한 접근 방식뿐만 아니라 내부의 원소 및 부분집할을 만들 수 있는 구조도 제공한다.  

<img width="294" alt="4" src="https://user-images.githubusercontent.com/43739827/73642903-e8624280-46b5-11ea-9b2c-1a12b0d21363.png"></img>

위에서 만든 Series 객체를 이용해 데이터 프레임 객체를 만들었다. 행과 열의 레이블을 따로 지정하지 않았으나 변수를 실행해보면 행과 열에 인덱스 레이블 이름이 있는 것을 볼 수 있다. 이렇듯 특정한 이름을 지정하지 않으면 정수형으로 자동 지정된다.  

데이터 프레임의 열의 레이블이 0이므로 이 이름으로 조회하면 데이터 프레임은 2차원이므로 이보다 차원이 낮은 1차원의 Series가 조회된다.  

데이터 프레임에서 인덱스 검색 조회의 기준은 항상 열이다. 슬라이싱은 행을 기준으로 하기 때문에 사용할 때 혼란을 야기할 수 있다. 그러므로 검색 기준을 명확하게 이해하고 있어야 한다.  

<img width="292" alt="5" src="https://user-images.githubusercontent.com/43739827/73643366-b43b5180-46b6-11ea-84da-c8fc5089e5dd.png"></img>  

조회 결과 name 속성이 0인것을 확인할 수 있다.

행을 검색하기 위해서는 iloc 인덱서를 사용한다. 실제 데이터 프레임의 행의 레이블은 순서와 상관없이 생성해도 되므로 실제 레이블을 검색하는 .loc 속성과 암묵적인 인덱스로 검색하는 .iloc 두 가지를 제공한다.  

행 단위로 검색해도 2차원인 데이터 프레임이 하나의 차원으로 축소된 1차원의 시리즈가 만들어진 것을 알 수 있다.

 <img width="287" alt="6" src="https://user-images.githubusercontent.com/43739827/73643709-54917600-46b7-11ea-8b37-7ac26d329bd5.png"></img>

더 차원을 축소해 데이터를 검색하려면 .iloc 인덱서의 행과 열에 정수 두 개를 넣어 행의 레이블과 열의 레이블을 지정한다. 그렇게하면 .iloc 인덱서는 최하위 원소를 검색해 결과를 보여준다.  

또한 파이썬 리스트처럼 행과 열을 연속적으로 호출해도 동일한 결과를 보여줄 수 있다.  

 <img width="206" alt="7" src="https://user-images.githubusercontent.com/43739827/73643941-c10c7500-46b7-11ea-97a5-12c42d47f960.png"></img>

* 데이터 구조의 편리성

판다스의 Series나 데이터 프레임 클래스는 다양한 속성이 있고 다양한 클래스의 객체를 이용한 구조로 이루어져 있다. 실제로 이 속성을 이용해 직접 접근도 가능하며, 다른 메소드를 사용해 내부적으로 접근을 하여 원하는 형태로 결과물을 출력하는 것도 가능하다.

* 행과 열에 대한 인덱스 정보 관리

판다스의 클래스에 대한 내부 정보에 접근할 수 있는 인덱스는 별도의 클래스이다. 이 인덱스는 내부 정보를 별도로 관리하면서 정보를 연결해 특정 원소 값과 부분 집합을 처리할 수 있는 구조를 구성한다. 데이터 처리는 numpy의 클래스로 처리하므로 numpy 모듈과의 연계성을 그대로 유지한다.  

하나의 데이터 프레임을 만들 때에는 행(index)과 열(column) 등 기본으로 3개의 매개변수가 있고 이것들을 전부 인자로 전달한다.  

<img width="804" alt="8" src="https://user-images.githubusercontent.com/43739827/73645185-2cefdd00-46ba-11ea-82f9-49f58ea9e023.png"></img>  

데이터 프레임의 생성 결과를 확인하면 행의 레이블과 열의 레이블이 지정되고, 내부 데이터 원소들의 값이 data로 전달된 값에 들어간 것을 볼 수 있다.  

<img width="361" alt="9" src="https://user-images.githubusercontent.com/43739827/73645429-a1c31700-46ba-11ea-8bb4-00e0a17eaeea.png"></img>

레이블을 관리하는 속성은 index 클래스의 인스턴스이고 데이터를 관리하는 속성은 numpy의 ndarray라는 것을 확인할 수 있다.  

<img width="375" alt="10" src="https://user-images.githubusercontent.com/43739827/73645623-febecd00-46ba-11ea-8565-7fe38bd2a838.png"></img>  

인덱서 .loc, .iloc 속성의 자료형을 type 클래스로 확인하면 두 개의 다른 클래스가 나오는 것을 볼 수 있다. type 클래스는 데이터 프레임등 판다스 클래스의 속성을 다양한 클래스로 내부의 정보를 사람들이 사용하기 편하게 보여줄 수 있는 기능을 제공한다.

* 인스턴스 관리 기준

판다스 모듈은 파이썬에서 클래스로 인스턴스를 만드는 것과 같다. 그러나 실제 연산을 처리할 때는 파이썬과 달리 내부의 원소를 갱신하는 것이 아닌 새로운 인스턴스를 만든다.  

필요한 경우에는 기존 인스턴스 내부를 갱신하기 위해 메소드 내부의 인스턴스에 지정해서 처리해야 한다. 판다스에 이런 기준이 있는 이유는 대용량 처리를 하기 위해서는 기존 인스턴스 내부를 갱신하기보다 새롭게 만들어서 처리하는 것이 더 빠르기 때문이다.  

또한 하나의 인스턴스를 다른 변수에 할당을 할 경우에도 기존 인스턴스의 레퍼런스를 공유해 처리하는 구조이다. 이를 별칭(alias)이라 하고, 실제 새로운 사본을 만들고자 한다면 copy 메소드를 사용해 다른 인스턴스를 생성하라는 것을 명확히 표시해야 한다.  

* 변수를 할당할 경우 항상 별칭으로 사용  
데이터 프레임을 하나 만들고 변수에 할당하여 그 내부의 값을 변경하면 원본에 있는 데이터를 갱신한다. 따라서 사본을 만들어서 사용하지 않으면 항상 원본도 같이 수정되므로 조심해야 한다.  

하나의 데이터 프레임을 만들 때 3행 3열인 총 9개 원소를 가지고 각 열의 이름을 a, b, c로 지정해 생성한 뒤 변수 df에 할당한다.

<img width="532" alt="11" src="https://user-images.githubusercontent.com/43739827/73646340-95d85480-46bc-11ea-8fac-ad71f68fcd5d.png"></img>  

새롭게 할당된 변수 df_a를 이용해 선택 연산자([])에 100이라는 값을 할당해서 갱신하였다. 실제 인덱스 연산자를 왼쪽에 넣고 할당 연산자 다음에 값을 넣어 데이터 프레임의 내부의 값을 변경하였다. 이 df_a를 확인하면 열 a 내의 원소들이 전부 100으로 바뀐것을 볼 수 있다.

<img width="194" alt="12" src="https://user-images.githubusercontent.com/43739827/73646597-2151e580-46bd-11ea-8292-f16828fb60f3.png"></img>  

최초에 만든 df 변수에 할당된 데이터 프레임을 확인해보면 열 a의 값이 변수 df_a 안의 a열의 값과 똑같이 변경된 것을 알 수 있다.  

두 개의 변수에 실제 값을 관리하는 속성인 values 안의 base 속성을 확인해보면 두 개의 레퍼런스가 같은것을 알 수 있다. 할당이란 별도로 사본을 만드는것이 아닌 원본을 참조하는 것이기 때문에 마치 데이터베이스의 CASCADE처럼 값을 수정하면 똑같이 변경되는것을 확인할 수 있다.  

<img width="383" alt="13" src="https://user-images.githubusercontent.com/43739827/73646907-bfde4680-46bd-11ea-9fee-38fbabe5da4c.png"></img>  

* 연산된 결과는 항상 새로운 인스턴스로 생성  
선택 연산자를 사용한 경우에는 기존 객체의 값을 바꿨지만, 다른 연산자나 메소드등은 대부분 연산을 수행할 때는 기존 원본은 변경하지 않고 새로운 사본을 만든다.  

연산된 결과는 대부분 같은 차원의 구조를 반환하지만, 가끔 차원이 축소된 결과를 반환하기도 한다.

<img width="236" alt="14" src="https://user-images.githubusercontent.com/43739827/73647361-a4c00680-46be-11ea-8316-d7f2399eed69.png">

위에서 생성된 df_a 변수에 있는 데이터 프레임을 가지고 특정 값 99를 덧셈으로 연산하여 다른 변수 df_b에 할당하였다. df_b를 빈 셀에 넣고 실행하면 실제 값이 변경된 것을 알 수 있다.  

<img width="381" alt="스크린샷 2020-02-03 오후 7 55 19" src="https://user-images.githubusercontent.com/43739827/73647571-21eb7b80-46bf-11ea-89c2-ce9f95df38c9.png"></img>  

변수 df_b와 df의 values 속성 안 base를 비교하면 False로 나온다. 이러한 이유는 덧셈 연산 등 대부분 판다스에서 제공하는 연산은 새로운 사본을 만들어 결과를 제공하므로, 변수에 할당하면 새로운 객체가 저장되기 때문이다. 몇 가지 예외가 있으나 주로 인덱스 연산자를 통한 할당은 기존 객체에 값을 변경하거나 열을 추가하는 것으로 이루어진다.  

실제 df 변수의 값을 확인하면 연산 결과와 상관 없이 원래 원소들이 그대로 유지된 것을 볼 수 있다.

Series와 데이터 프레임이 똑같이 처리되는지 확인하고자 한다. 먼저 numpy를 import하고 Series의 data를 arrange 함수로 4개의 원소를 만든다. index 매개변수에 a,b,c,d 4개의 이름을 부여해 원소를 생성한다.

<img width="526" alt="16" src="https://user-images.githubusercontent.com/43739827/73647995-f9b04c80-46bf-11ea-80b1-3da4ae6ef199.png"></img>  

새로운 s2 변수에 Series가 할당된 s1을 할당한 후에 두 개의 레퍼런스를 확인하면 두 개의 변수에 저장된 변수의 레퍼런스가 같은것을 확인할 수 있다.

<img width="215" alt="17" src="https://user-images.githubusercontent.com/43739827/73648149-41cf6f00-46c0-11ea-916a-79e8e2888cc0.png"></img>

다른 변수 s3에 s1 내부의 .copy 메소드를 이용해 할당한 후에 변수에 저장된 시리즈의 래퍼런스를 비교하면 두 개의 레퍼런스가 다른 것을 확인할 수 있다.

* 인덱스 검색과 슬라이싱 처리  
판다스에서의 인덱스 검색과 슬라이싱은 대괄호연산 및 마스킹(masking) 검색, 팬시(fancy) 검색 등이 추가되었다. 또한 속성인 인덱서(indexer)라는 개념도 추가되어 행 중심으로 검색하는 기능도 지원한다. 어떤 경우라도 대괄호 연산을 이용하려면 실제 '__getitem__' 스페셜 메소드가 수형되어 있어야 한다.

<img width="677" alt="18" src="https://user-images.githubusercontent.com/43739827/73648465-f5d0fa00-46c0-11ea-8cf4-70d5594bea71.png"></img>

판다스에서는 파이썬처럼 클래스의 인스턴스 메소드가 함수로 유지되는 것을 알 수 있다. 그리고 실제 인스턴스 개체와 메소드가 바인딩되면 메소드로 실행되는 것도 볼 수 있다.

<img width="893" alt="19" src="https://user-images.githubusercontent.com/43739827/73648812-b0f99300-46c1-11ea-96e4-de0b7dee2c86.png"></img>  

데이터 프레임을 만들고 인덱스를 검색하면 파이썬은 행 단위 처리를 기준으로 하지만 판다스의 데이터 프레임은 열 단위를 기준으로 처리하는 것을 볼 수 있다.  

<img width="312" alt="20" src="https://user-images.githubusercontent.com/43739827/73649406-10a46e00-46c3-11ea-86ee-f4bb335c4f95.png"></img>

실제 스페셜 메소드(__getitem__)에 직접 인자를 넣고 처리해도 잘 실행된다면 연산자를 이용해 실행하거나 스페셜 메소드를 직접 실행해도 같은 결과가 나오는 것을 알 수 있다. 즉, 실제 연산자는 모두 스페셜 메소드를 변환해 작동되는 것임을 알 수 있다.  

<img width="288" alt="21" src="https://user-images.githubusercontent.com/43739827/73649578-6b3dca00-46c3-11ea-9a64-3cccdbd503e7.png"></img>

데이터 프레임의 한 열을 다른 변수에 저장하면 하나의 Series가 만들어지는 것을 알 수 있다. 이 Series의 인덱스 검색 연산자와 스페셜 메소드를 가지고 처리하는 결과가 같음을 알 수 있다.  

<img width="341" alt="22" src="https://user-images.githubusercontent.com/43739827/73649724-c53e8f80-46c3-11ea-8c12-2a0d7e1688ae.png"></img>  

파이썬에서는 하나의 키 값이 인덱스 번호를 기반으로 한다. 반면 판다스는 Series와 데이터 프레임의 테이블 이름으로 인덱스 검색이 가능하다. 실제 논리식이 계산된 결과인 Series나 데이터 프레임을 가지고 인덱스 검색에서 사용하는 것도 가능하다.  

특정 원소들의 값이 True일 때는 가져오지만 False일 때는 가져오지 않고 없는 값으로 처리하기 위해 NaN으로 처리되면 정수 자료형도 실수 자료형으로 자동으로 변환이 되는것을 알 수 있다.  

## 3. 메소드 & 함수
-----------------

판다스는 다양한 함수와 메소드를 제공한다. 대량의 데이터를 처리하기 위해서 순환문 없이 처리하는 기준을 수용했기 때문에 모양이나 차원이 다른 경우는 먼저 브로드캐스팅을 해서 모양을 맞춘 후에 내부의 원소를 계산한다. 또한 없는 데이턱가 발생해도 내부적으로 예외를 발생시키지 않고 데이터를 처리하면 차원별로 계산이 가능하다.  

판다스에서는 다양한 파일을 읽어와 데이터 프레임을 만들 수도 있지만 한글 등 문자열 데이터에 대한 변환인 인코딩또한 필요하다.  

* 브로드캐스팅 및 벡터와 연산

판다스에 있는 Series나 데이터 프레임은 여러 원소를 가진 다차원 데이터이므로 이 원소를 순환문을 이용해 처리하기보다 내부적으로 각 원소별로 처리하는 것이 더 편하다.

여러 원소를 가진 Series나 데이터 프레임의 원소의 개수를 맞추는 것을 브로드캐스팅이라하고 이를 한 번에 연산 처리하는 것을 벡터화 연산(vectorizing)이라고 한다.  

Series나 데이터 프레임은 여러 차원으로 구성된 데이터이므로 이를 계산할 경우 각 원소들의 개수를 차원 단위로 맞추어야 한다. 이를 자동으로 맞춘 후에 연산을 처리하므로 실제 차원이 다르다면 차원을 맞추는 일을 먼저 수행한 후에 연산을 처리한다.  
각 원소별로 계산할 때 브로드캐스팅 후에 순환을 수동으로 처리하지 않고 자동으로 처리되는 벡터화 연산을 수행해 모든 원소를 계산하도록 처리한다.

<img width="650" alt="23" src="https://user-images.githubusercontent.com/43739827/73650430-86113e00-46c5-11ea-82e2-05387d162a3f.png"></img>  

데이터 프레임을 만들 때 내부의 원소가 9개다. 이 차원을 3행 3열로 구성한다. 열의 레이블 이름을 문자열로 주고 이를 list로 생성하면 각 열의 이름이 a, b, c로 구성되는 것을 알 수 있다. 행의 레이블은 지정하지 않았으므로 내부적으로 일련의 숫자로 처리되는 것을 볼 수 있다.  

<img width="639" alt="24" src="https://user-images.githubusercontent.com/43739827/73650582-d7213200-46c5-11ea-8165-3eb82b6abf74.png"></img>  

같은 값으로 9개의 원소를 가진 것을 3개씩 3개의 행(3 X 3)을 가지는 리스트로 넣고 열의 이름을 columns에 넣어 데이터 프레임을 만든 뒤 df1이라는 변수에 할당했다.

<img width="201" alt="25" src="https://user-images.githubusercontent.com/43739827/73650676-0a63c100-46c6-11ea-8b0c-6ed213e98118.png"></img>  

변수 df에 할당된 데이터 프레임에 상수 값 3을 더하면 실제 상수 3이 3행3열의 데이터 프레임으로 바뀌는 브로드캐스팅 처리가 되고 + 연산자로 각 원소별로 계산이 된다. 기존 데이터 프레임의 각 원소에 3씩 증가된 것을 볼 수 있다.

<img width="191" alt="26" src="https://user-images.githubusercontent.com/43739827/73650776-46972180-46c6-11ea-81f4-889b82d01f2b.png"></img>  

두 개의 변수 df, df1 데이터 프레임에 + 연산자로 더했을 경우 위의 결과와 같은 것을 알 수 있다. 이 연산을 확인하면 실제 순환문이 없이 내부적으로 9개의 원소들끼리의 덧셈 연산이 처리되었는데, 이런 처리를 벡터화 연산이라 한다.  

<img width="314" alt="27" src="https://user-images.githubusercontent.com/43739827/73650855-7f36fb00-46c6-11ea-8d95-a735ffa00e2c.png"></img>

파이썬의 덧셈 연산은 내부적인 __add__ 스페셜 메소드로 제공한다. 이 연산자 내부의 함수를 __func__ 에 확인하면 실제 함수가 들어 있는 것을 알 수 있다.  

파이썬은 내부적으로 method라는 클래스가 만드는 메소드가 있고 그 메소드 내부에는 실제 수행하는 함수가 존재한다.  

<img width="269" alt="28" src="https://user-images.githubusercontent.com/43739827/73650982-c4f3c380-46c6-11ea-9cef-95137d3f2559.png"></img>

판다스에서는 데이터 프레임 안의 연산자 말고도 add라는 메소드도 별도로 제공한다. 이 add라는 메소드는 스페셜 메소드와 동일하게 method 클래스에 만들어진 것을 알 수 있다. 메소드 내부에 __func__ 을 보면 함수가 저장되었다.

판다스에서 스페셜 메소드와 메소드를 이중으로 제공하는 이유는 실제 연산자 연산 말고도 다양한 매개변수를 메소드에 넣어 기능을 확장 처리할 수 있도록 하기 위함이다.  

<img width="336" alt="29" src="https://user-images.githubusercontent.com/43739827/73651122-1c922f00-46c7-11ea-9405-941f91ed3533.png"></img>  

스페셜 메소드와 메소드 안의 함수가 같은지를 비교해보면 서로 다른 함수가 저장된 것을 알 수 있다. 실제 매개변수 차이로 두 개의 함수가 별도로 만들어져 __func__ 에 할당하고 처리하게 된다.

* 누락 값을 포함한 데이터 처리 
