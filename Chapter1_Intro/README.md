Introduction
============

판다스는 파이썬의 데이터 분석 라이브러리로써 행과 열로 이루어진 테이블형태의 데이터를 관리하는데에 사용된다.

## 1. 판다스의 특징

* 데이터 그룹화   
 테이블의 열을 그룹화하거나 여러 개의 데이터 프레임들을 하나로 통합하여 하나의 정보로 요약할 수 있다.

* 데이터 분석 및 시각화  
 데이터의 수치화가 간편하며 이것을 그래프로 시각화할 수 있다. 또한 판다스의 데이터 프레임(Data Frame)은 하나의 자료형만을 가지게 되는데 이것은 데이터 분석에 필요한 변수를 구성하는 기본 조건을 만족한다.  
 데이터 분석에서의 변수분류 방법은 수치형과 텍스트형이 있으며 수치형은 연속형(주어진 일정 범위의 실수)과 정수형(정수값)을 구분하며 텍스트형에는 일반 텍스트와 일정 범위를 가진 범주형으로 나뉘어진다.  

 <img width="396" alt="0" src="https://user-images.githubusercontent.com/43739827/73828871-5ee17a80-4845-11ea-91fd-cc84fa1ee67b.png"></img>  


## 2. 클래스

판다스는 넘파이 모듈을 기반으로 만들어졌기 때문에 넘파이 기본연산을 모두 제공한다. 그러나 판다스는 넘파이와 달리 행(Row)과 열(Column)에 각각 라벨링하기 때문에 각 열의 타입이 달라도 된다. 이는 내부 요소들에 빠르게 접근하기 위함이다.  

<img width="1079" alt="1-1" src="https://user-images.githubusercontent.com/43739827/73830606-49ba1b00-4848-11ea-8ffe-dd44fb9a6a7e.png"></img>  
> Number의 Column을 보면 전부 정수형이 아닌것을 확인 할 수 있다.  

* 연산자와 메소드
판다스에서 클래스를 만들 때에 numpy의 배열인 ndarray를 이용한다. 그렇기 때문에 넘파이 모듈과 판다스의 선언 형식을 보면 상당히 비슷함을 알 수 있다.   

<img width="1080" alt="1-2" src="https://user-images.githubusercontent.com/43739827/73831111-1deb6500-4849-11ea-8ca8-799fc38cb721.png"></img>  
> 시리즈와(Series)와 ndarray의 선언 방식 비교

**시리즈(Series)** 는 1차원 벡터로 파이썬에서의 리스트를 입력하면 생성된다. 또한 레이블을 붙여 인덱스를 활용할 수 있으며 암묵적인 숫자 타입의 인덱스도 실행 가능하다.  

<img width="1084" alt="1-3" src="https://user-images.githubusercontent.com/43739827/73832533-b08d0380-484b-11ea-81fd-1b58b56940e1.png"></img>
> 실행결과와 같이 자료형을 지정하지 않을 때는 내부적으로 원소 값을 확인하여 추론해 가장 적절한 자료형을 선택한다.

시리즈에 덧셈 연산자(+)를 사용하여 계산한 결과는 시리즈로 반환된다. 이유는 판다스 모듈의 기본 원칙이 원래의 시리즈 값을 바꾸지 않고 새롭게 만들어 반환하는 것이기 때문이다.

<img width="1085" alt="1-4" src="https://user-images.githubusercontent.com/43739827/73833036-a7506680-484c-11ea-8db4-7d60ed07202d.png"></img>
> 시리즈의 값에 변화가 없는것을 확인할 수 있다.  

덧셈 연산자 이외에도 .add()메소드를 사용하면 동일한 결과를 출력할 수 있다.  

<img width="1082" alt="1-5" src="https://user-images.githubusercontent.com/43739827/73833195-e8e11180-484c-11ea-97aa-7d331ff08679.png"></img>
> 시리즈 + 시리즈 == 시리즈.add(시리즈)  

* 검색과 슬라이싱  
위에서 사용했던 시리즈를 가지고 데이터 프레임을 만들었다. 만들 때에 아무런 조건을 설정하지 않았으나 출력된 결과물을 확인해보면 자동으로 행과 열에 라벨링이 되어있다. 이처럼 아무런 조건을 지정하지 않았을때는 0부터 시작하는 정수형으로 자동 설정된다.    

<img width="1083" alt="1-6" src="https://user-images.githubusercontent.com/43739827/73833543-7a508380-484d-11ea-8cf4-5274e6d51dca.png"></img>  
> 행과 열에 0부터 시작하는 정수가 라벨링되어진것을 확인할 수 있다.

데이터 프레임의 열(Column)의 레이블이 0으로 되어있기에 검색조건을 **Df[0]** 으로하면 출력결과가 시리즈인 것을 확인할 수 있다. 이것은 데이터프레임은 2차원으로 구성되어있기 때문에 1차원 낮은 시리즈로 검색된 것이다.

<img width="1082" alt="1-7" src="https://user-images.githubusercontent.com/43739827/73834205-a6203900-484e-11ea-8a04-7d431c80abd6.png"></img>  
> 데이터 프레임의 검색기준은 항상 열이다. 슬라이싱은 행을 기준으로 하기 때문에 두가지에 대해서 확실하게 ] 알 필요가 있다.  

데이터 프레임을 검색하면 name이라는것이 함께 출력되는 것을 확인할 수 있다. name은 조회하는 열의 레이블을 나타내며 만약 데이터 프레임을 생성했을때 레이블을 설정했었다면 그 레이블을 검색 조건으로 지정해야 한다. 만약 레이블로 지정되지 않은 값을 검색조건으로 했을 때엔 **KeyError** 가 발생하게 된다.

<img width="1084" alt="1-9" src="https://user-images.githubusercontent.com/43739827/73835258-72461300-4850-11ea-8faa-2b1d22089256.png"></img>  


행을 검색하기 위해서는 iloc 인덱서를 사용한다. 실제 데이터 프레임의 행의 레이블은 순서와 상관없이 생성해도 되므로 실제 레이블을 검색하는 .loc 속성과 암묵적인 인덱스로 검색하는 .iloc 두 가지를 제공한다.  
행을 기준으로 검색하기 위해서는 **.loc** 혹은 **.iloc** 을 사용해야 한다. 두 함수의 차이는 loc은 인덱스를 기준으로 행을 읽어들이지만 iloc은 실제 행 번호를 기준으로 읽어들인다는 것이다.  

<img width="1087" alt="1-10" src="https://user-images.githubusercontent.com/43739827/73835848-7b83af80-4851-11ea-96a0-75584e4e0815.png"></img>
> .loc은 인덱스를 기준으로 데이터를 읽어들이기 때문에 행 번호나 인덱스가 아닌 값을 입력하면 오류가 발생한다.

<img width="1085" alt="1-11" src="https://user-images.githubusercontent.com/43739827/73836050-cef5fd80-4851-11ea-8aa1-f1fbbb6d3c03.png"></img>  
> .iloc은 행 번호를 기준으로 하기 때문에 데이터 프레임의 가장 마지막 행을 검색하고자 한다면 파이썬의 리스트처럼 [-1]을 해주면 된다.  

행 단위의 검색 또한 열 단위 검색과 마찬가지로 시리즈가 반환되는것을 확인할 수 있다. 만약 차원을 축소하여 데이터를 검색하고자 한다면 .iloc 함수에 특정 행과 열을 입력한다. 혹은 파이썬의 리스트와 마찬가지로 행,열을 연속으로 호출해도 동일한 결과를 보여준다.

<img width="1084" alt="1-12" src="https://user-images.githubusercontent.com/43739827/73836512-c651f700-4852-11ea-8639-0eb05d0124d7.png"></img>
> .iloc 함수를 사용하지 않은 일반적인 호출을 할 때엔 검색기준이 ['열(Column) 조건']['행(Row) 조건']임을 명심한다.   

* 데이터 구조의 편리성

시리즈와 데이터 프레임에는 다양한 속성들이 있다. 이 속성들을 이용해 직접적인 접근이나 다른 메소드를 활용한 접근도 가능하다.  
<img width="1438" alt="1-13" src="https://user-images.githubusercontent.com/43739827/73837054-f64dca00-4853-11ea-8113-e8131fb4fc23.png"></img>
> 판다스 공식 사이트에서 속성들에 대한 정보들을 확인할 수 있다. [pandas DOCS](https://pandas.pydata.org/docs/reference/series.html, "DOCS link")  


* 행과 열에 대한 인덱스 정보 관리

판다스의 내부 요소들에 접근할 수 있는 인덱스는 별도의 클래스다. 인덱스란 내부 요소들을 별도로 관리하면서 정보를 연결해 특정 원소 값과 부분 집합을 처리할 수 있는 구조이다. 이 때의 데이터 처리는 넘파이를 이용하기 때문에 넘파이 모듈과의 연계성을 그대로 유지한다.

데이터 프레임을 만들기 위해서는 기본적으로 행,열,데이터 3개의 매개변수가 요구된다. 그렇지만 행과 열을 별도로 입력하지 않았을때는 0부터 시작하는 정수가 자동적으로 입력된다. 데이터 프레임의 생성 결과를 확인해 보면 설정한 행과 열의 레이블이 지정되어있고 내부 원소들이 data로 입력한 값임을 확인할 수 있다.

<img width="1085" alt="1-14" src="https://user-images.githubusercontent.com/43739827/73837721-614bd080-4855-11ea-8d14-2ca5fdad1fed.png"></img>  
> 행(index)과 열(column)을 지정하는 방식이 다르지만 실제론 같은 의미이미로 둘 중 아무렇게나 사용해도 상관없다.    

레이블을 관리하는 index와 columns의 속성은 indexes 클래스의 인스턴스, 내부 원소들을 관리하는 속성은 넘파이의 ndarray임을 확인할 수 있다.  

<img width="1082" alt="1-15" src="https://user-images.githubusercontent.com/43739827/73838145-58a7ca00-4856-11ea-9325-134fed5e49e9.png"></img>
> type 클래스는 내부 정보를 사용자들이 편하게 볼 수 있게끔 하는 역할을 한다.  

* 인스턴스 관리 기준  
판다스는 파이썬에서 클래스를 이용해 인스턴스를 만드는 것과 같다. 차이점은 판다스는 연산을 처리할때 내부의 요소들을 갱신하는것이 아니라 새로운 인스턴스를 만들어 반환한다는 것이다. 만약 기존의 값을 갱신하고자 한다면 메소드 내에서 조건을 지정하여 처리해야 한다. 판다스가 이런 규칙을 고집하는 이유는 대용량 처리를 하기 위해서는 기존 값들의 갱신보다는 새로운 인스턴스를 만들어 반환하는 것이 훨씬 빠르기 때문이다.  

* 변수를 할당할 경우 항상 별칭(alias)으로 사용  
데이터 프레임을 생성해 변수에 할당하고, 할당된 데이터 프레임의 값을 변경하면 원본 데이터 프레임의 값도 갱신된다.  

<img width="1084" alt="1-16" src="https://user-images.githubusercontent.com/43739827/73838958-37e07400-4858-11ea-9532-0bbbc101b553.png"></img>
> 3X3의 각 요소의 값이 다른 데이터 프레임 df를 생성하여 df_a에도 할당하였다. 그 후 1열의 값을 100을 주어 df_a의 값이 갱신된것을 확인하고 원본 데이터 프레임인 df의 값이 갱신된것을 확인하였디.

<img width="1087" alt="1-17" src="https://user-images.githubusercontent.com/43739827/73839242-d8cf2f00-4858-11ea-9a3f-2e03e6e4a237.png"></img>  
> df와 df_a의 id를 확인해보면 같음을 확인할 수 있다. 할당이란 별도로 사본을 만드는것이 아닌 원본을 참조하는 것이기 때문에 마치 데이터베이스의 CASCADE처럼 값을 수정하면 똑같이 변경되는것을 확인할 수 있다.  

* 연산된 결과는 항상 새로운 인스턴스로 반환
위에서 생성한 데이터프레임 df를 같은 값으로 한 번더 더하여 df_b라는 변수에 할당해주었다. 그 후 df_b와 df의 id를 확인했을때 서로 다름을 확인할 수 있다. 이러한 이유는 판다스의 연산은 새롭게 사본을 만들어 반환하므로 변수에 할당하면 새로운 객체가 지정되기 때문이다. 실제로 df의 값들은 변하지 않았음을 확인할 수 있다.

<img width="1084" alt="1-18" src="https://user-images.githubusercontent.com/43739827/73839746-13859700-485a-11ea-9e1c-9a76dab4695e.png"></img>  

시리즈도 데이터 프레임과 같은 방식을 사용하는지 확인하고자 한다. 넘파이를 활용한 0~6까지의 정수로 채운 시리즈를 하나 만들어 se_1이라 부른다. 이것을 se_2에 할당하고 se_2의 특정 값을 변경하면 원본인 se_1에도 변화가 생긴것을 확인할 수 있다.  

<img width="1083" alt="1-19" src="https://user-images.githubusercontent.com/43739827/73840631-edf98d00-485b-11ea-962a-dd4ac5e49bfe.png"></img>

이번에는 se_1의 사본을 만들어 se_3에 입력한다. se_3의 특정 값을 변경해도 원본인 se_1에는 아무런 변화가 없음을 확인할 수 있다.  

<img width="1086" alt="1-20" src="https://user-images.githubusercontent.com/43739827/73840828-6d875c00-485c-11ea-8814-1660412b4dac.png"></img>

* 인덱스 검색과 슬라이싱 처리  
판다스에서의 인덱스 검색과 슬라이싱은 대괄호연산([]) 및 마스킹(masking) 검색, 팬시(fancy) 검색 등이 추가되었다. 또한 속성인 인덱서(indexer)라는 개념도 추가되어 행 중심으로 검색하는 기능도 지원한다. 어떤 경우라도 대괄호 연산을 이용하려면 스페셜 메소드인 **__getitem__** 가 존재해야 한다.

<img width="1085" alt="1-21" src="https://user-images.githubusercontent.com/43739827/73841145-47ae8700-485d-11ea-92b2-d35258c4c1e6.png"></img>  

판다스에서는 파이썬처럼 클래스의 인스턴스 메소드가 함수로 유지되는 것을 알 수 있다. 그리고 실제 인스턴스 개체와 메소드가 바인딩되면 메소드로 실행되는 것도 볼 수 있다.

<img width="1100" alt="1-22" src="https://user-images.githubusercontent.com/43739827/73841492-24d0a280-485e-11ea-9e95-a41c6940475c.png"></img>  

데이터 프레임의 인덱스를 검색해보면 파이썬과 달리 열 단위를 기준으로 처리하는 것을 확인해볼 수 있다. 또한 스페셜 메소드에 인자를 넣고 검색해도 동일한 결과가 나오는 것을 확인할 수 있는데 이는 실제 연산자들이 모두 스페셜 메소드를 변환한것임을 알 수 있다.  

<img width="1090" alt="1-23" src="https://user-images.githubusercontent.com/43739827/73841813-b50ee780-485e-11ea-9055-78c0cf7f10c4.png"></img>  

생성한 데이터 프레임의 한 열을 다른 변수에 할당해주면 시리즈가 되는것을 확인할 수 있다. 또한 만들어진 시리즈의 인덱스 검색 연산자와 스페셜 메소드 검색 연산 결과가 동일함을 확인할 수 있다.  

<img width="1096" alt="1-24" src="https://user-images.githubusercontent.com/43739827/73842103-43836900-485f-11ea-919c-552c38c53298.png"></img>

판다스는 파이썬과 다르게 테이블 이름으로 인덱스 검색이 가능하다. 또한 논리식을 사용하여 조건에 합당하는 값들만 가지고 올 수도 있다. 만약 이 조건에 부합하지 않는다면 이를 **False** 로 간주하고 존재하지 않는 값으로 처리하기 위해 NaN으로 처리된다.  

<img width="1093" alt="1-25" src="https://user-images.githubusercontent.com/43739827/73842789-9d386300-4860-11ea-84cd-1d39c81db062.png"></img>
> 구체적인 행과 열을 지정하지 않고 단순하게 테이블 이름을 검색 조건으로 지정하면 된다.  

## 3. 메소드 & 함수

판다스는 대용량의 데이터를 처리하기 위해 loop를 사용하지 않고 모양이나 차원이 다른 경우에 브로드캐스팅을 해서 모양을 맞추고 계산한다. 또한 데이터가 없더라도 내부적으로 예외를 발생시키지 않고 데이터를 처리하면 각 차원별로 계산이 가능하다.  

* 브로드캐스팅 및 벡터와 연산  

브로드캐스팅이란 원소의 개수가 맞지 않는 시리즈나 데이터 프레임간의 연산을 위해 모양을 맞춰주는 것을 말하며 이를 한 번에 연산처리하는것을 벡터화 연산(vectorizing)이라고 한다. loop를 사용하지 않는 이유는 시리즈나 데이터 프레임이 다차원 데이터이기 때문에 내부에서 각 원소별로 처리하는 것이 더 편하기 대문이다.

<img width="1097" alt="1-26" src="https://user-images.githubusercontent.com/43739827/73843930-f1444700-4862-11ea-97fe-bdecff46523c.png"></img>  
> 4행 3열의 테이블에 [10, 20, 30]의 리스트를 곱하였다. 이때 사용되는 것이 브로드캐스팅이다.  

<img width="1097" alt="1-27" src="https://user-images.githubusercontent.com/43739827/73844319-b393ee00-4863-11ea-906a-3bf16fbae1c9.png"></img>  
> 브로드캐스팅의 조건으로는 열의 개수가 같아야 한다. 

Series나 데이터 프레임은 여러 차원으로 구성된 데이터이므로 이를 계산할 경우 각 원소들의 개수를 차원 단위로 맞추어야 한다. 이를 자동으로 맞춘 후에 연산을 처리하므로 실제 차원이 다르다면 차원을 맞추는 일을 먼저 수행한 후에 연산을 처리한다.  
각 원소별로 계산할 때 브로드캐스팅 후에 순환을 수동으로 처리하지 않고 자동으로 처리되는 벡터화 연산을 수행해 모든 원소를 계산하도록 처리한다.

<img width="650" alt="23" src="https://user-images.githubusercontent.com/43739827/73650430-86113e00-46c5-11ea-82e2-05387d162a3f.png"></img>  

데이터 프레임을 만들 때 내부의 원소가 9개다. 이 차원을 3행 3열로 구성한다. 열의 레이블 이름을 문자열로 주고 이를 list로 생성하면 각 열의 이름이 a, b, c로 구성되는 것을 알 수 있다. 행의 레이블은 지정하지 않았으므로 내부적으로 일련의 숫자로 처리되는 것을 볼 수 있다.  

<img width="639" alt="24" src="https://user-images.githubusercontent.com/43739827/73650582-d7213200-46c5-11ea-8165-3eb82b6abf74.png"></img>  

같은 값으로 9개의 원소를 가진 것을 3개씩 3개의 행(3 X 3)을 가지는 리스트로 넣고 열의 이름을 columns에 넣어 데이터 프레임을 만든 뒤 df1이라는 변수에 할당했다.

<img width="201" alt="25" src="https://user-images.githubusercontent.com/43739827/73650676-0a63c100-46c6-11ea-8b0c-6ed213e98118.png"></img>  

변수 df에 할당된 데이터 프레임에 상수 값 3을 더하면 실제 상수 3이 3행3열의 데이터 프레임으로 바뀌는 브로드캐스팅 처리가 되고 + 연산자로 각 원소별로 계산이 된다. 기존 데이터 프레임의 각 원소에 3씩 증가된 것을 볼 수 있다.

<img width="191" alt="26" src="https://user-images.githubusercontent.com/43739827/73650776-46972180-46c6-11ea-81f4-889b82d01f2b.png"></img>  

두 개의 변수 df, df1 데이터 프레임에 + 연산자로 더했을 경우 위의 결과와 같은 것을 알 수 있다. 이 연산을 확인하면 실제 순환문이 없이 내부적으로 9개의 원소들끼리의 덧셈 연산이 처리되었는데, 이런 처리를 벡터화 연산이라 한다.  

<img width="314" alt="27" src="https://user-images.githubusercontent.com/43739827/73650855-7f36fb00-46c6-11ea-8d95-a735ffa00e2c.png"></img>

파이썬의 덧셈 연산은 내부적인 __add__ 스페셜 메소드로 제공한다. 이 연산자 내부의 함수를 __func__ 에 확인하면 실제 함수가 들어 있는 것을 알 수 있다.  

파이썬은 내부적으로 method라는 클래스가 만드는 메소드가 있고 그 메소드 내부에는 실제 수행하는 함수가 존재한다.  

<img width="269" alt="28" src="https://user-images.githubusercontent.com/43739827/73650982-c4f3c380-46c6-11ea-9cef-95137d3f2559.png"></img>

판다스에서는 데이터 프레임 안의 연산자 말고도 add라는 메소드도 별도로 제공한다. 이 add라는 메소드는 스페셜 메소드와 동일하게 method 클래스에 만들어진 것을 알 수 있다. 메소드 내부에 __func__ 을 보면 함수가 저장되었다.

판다스에서 스페셜 메소드와 메소드를 이중으로 제공하는 이유는 실제 연산자 연산 말고도 다양한 매개변수를 메소드에 넣어 기능을 확장 처리할 수 있도록 하기 위함이다.  

<img width="336" alt="29" src="https://user-images.githubusercontent.com/43739827/73651122-1c922f00-46c7-11ea-9405-941f91ed3533.png"></img>  

스페셜 메소드와 메소드 안의 함수가 같은지를 비교해보면 서로 다른 함수가 저장된 것을 알 수 있다. 실제 매개변수 차이로 두 개의 함수가 별도로 만들어져 __func__ 에 할당하고 처리하게 된다.

* 누락 값을 포함한 데이터 처리  
판다스 클래스들의 특징은 실제 원소의 값이 들어가 있지 않아도 예외가 없이 처리된다는 것이다. 판다스 모듈에 있는 대부분의 클래스는 대용량 데이터를 처리할 때 누락 값(missing)이 있어도 예외를 발생시키지 않고 처리한다.  

판다스에서는 누락값을 표시하는 방법으로 NaN을 사용한다. 이 값은 일반적으로 numpy 모듈에서의 np.nan을 의미한다.  

누락 값 연산을 처리할 때 수학 메소드들은 실제 값들이 있을 때만 계산을 수행하고 아닌 경우를 NaN으로 처리한다. 이 NaN값은 논리식으로 비교하면 항상 False 처리가 된다.

<img width="393" alt="30" src="https://user-images.githubusercontent.com/43739827/73730927-f7f78f00-477a-11ea-886e-2d2179da0d58.png"></img>  

데이터 프레임 생성자를 이용해 인스턴스를 만들 때 두 개의 원소는 정수를 넣고 나머지 원소는 누락 값인 np.nan을 처리해 생성한다.  

누락 값인 NaN은 판다스에서는 float로 지정해 관리하므로 생성된 자료의 데이터 자료형도 float64가 된다.  

<img width="286" alt="31" src="https://user-images.githubusercontent.com/43739827/73731482-e793e400-477b-11ea-95bb-803aa869a51d.png"></img>  

데이터 프레임 내부의 .sum 메소드를 실행하면 모든 원소를 더하고 더한 값을 반환한다. 반환된 값은 1차원 Series로 만들어지는데, .sum 메소드는 계산결과를 한 차원 축소한 결과를 반환한다.  

누락 값은 계산을 하지 않고 숫자만 계산해 반환한다. .sum 메소드에서 모든 원소를 전부 계산하고 싶을 때는 매개변수 skipna=True로 지정하면 누락 값을 포함해 계산한다. 그리고 그 결과는 NaN으로 처리도니다. 모든 NaN 값과 계산된 결과는 NaN으로 처리된다.

<img width="244" alt="32" src="https://user-images.githubusercontent.com/43739827/73731728-56713d00-477c-11ea-99f3-a58afa03a691.png"></img>  

비교 연산자를 사용하면 True와 False로 결과 값을 제공한다. 누락 값과의 비교는 항상 False로 처리된다.

<img width="211" alt="33" src="https://user-images.githubusercontent.com/43739827/73731844-87517200-477c-11ea-98a3-ecfa2538f2a3.png"></img>  

누락 값인 np.nan을 이용해 비교 연산자를 사용하면 같은 누락 값에 대해서도 False로 표시한다. 즉, 누락 값은 비교 연산에 사용할 수 없다는 표시이다.

## 4.축
판다스는 다차원 계산을 처리하므로 실제 각 차원에 대한 축을 기준으로 계산한다. 따라서 축을 이용해 데이터의 원소를 연결하기 위해 축(axis)이 무엇인지 이해해야 한다.  

판다스에서는 클래스의 1차원인 Series와 2차원인 데이터 프레임을 생성한 후에 다양한 메소드를 지원하고 매개변수 axis에 각 축에 대한 정보를 0, 1로 지정해 각 축을 기준으로 처리한다.  

검색이나 병합 등 다양한 함수나 메소드를 처리할 대도 축을 기준으로 연결하므로 축에 대해 정확히 이해할 필요가 있다.

* 축  
다차원 배열을 처리할 때 1차원인 Series는 축이 하나만 존재하므로 기본으로 0만을 사용하며 2차원인 데이터 프레임은 0인 행과 1인 열로 만들어진다. 보통 축은 1차원일 때 0(index)만 있고 2차원일 때 0인 행과 1인 열을 가진다면, 판다스에서는 축에 대한 정보를 일관성있게 처리한다.  

축은 열과 행을 처리하는 다양한 메소드에서 사용하고 실제 내부의 원소들을 계산할 때에도 사용된다. 원소들을 계산할 때는 0축은 각 열에 대한 행의 원소들을 계산하도록 하고 1축은 각 행에 대한 열의 원소들을 계산한다.  

<img width="641" alt="34" src="https://user-images.githubusercontent.com/43739827/73732730-072c0c00-477e-11ea-8c30-6a421d0c1dd1.png"></img>  

행과 열은 각각 axis=0과 axis=1을 의미한다. 계산할 때는 axis를 주고 그 축에 대한 고정을 지정하면, 고정된 축을 기준으로 내부의 값들이 계산된다.  

<img width="344" alt="35" src="https://user-images.githubusercontent.com/43739827/73733175-d3051b00-477e-11ea-91c5-cfc157c91c42.png"></img>  

4개의 원소를 갖는 하나의 Series를 만들 때 행에 대한 레이블인 index 매개변수에 인자를 넣지 않고 생성한다. Series는 1차원이므로 0번 축인 열을 기준으로 만들어지게 된다.  

축을 고정해서 계산한다는 것은 행을 고정해서 계산하라는 뜻이다. Series는 기본적으로 행에 대한 계산을 하기 때문이다.

<img width="282" alt="36" src="https://user-images.githubusercontent.com/43739827/73733334-224b4b80-477f-11ea-9ac8-a4e1b993adc0.png"></img>  

따라서 Series의 객체에 있는 .sum 메소드에 axis=0을 입력하면 행을 고정해서 그 내부의 원소를 계산하라는 뜻이다. 결과는 모든 원소를 더한 값이 정수로 출력된다.  

<img width="893" alt="37" src="https://user-images.githubusercontent.com/43739827/73733707-c9c87e00-477f-11ea-8539-738db515ff3d.png"></img>  

2행 4열의 리스트를 넣어 데이터 프레임을 만들었다. 행과 열에 대한 정보를 할당하지 않아서 내부적으로 숫자로 행과 열의 레이블이 자동으로 입력된 것을 확인할 수 있다.  

<img width="885" alt="38" src="https://user-images.githubusercontent.com/43739827/73733851-072d0b80-4780-11ea-85a9-5eedde44423a.png"></img>  

.sum 메소드를 가지고 데이터 프레임의 axis=0을 전달하는 것은 열 단위로 계산을 하라는 뜻이다. 반대로 생각해보면 열을 기준으로 고정했기 때문에 열이 레이블에 고정되어 있어 계산된 결과 값이 열 단위로 남아있다.  

<img width="888" alt="39" src="https://user-images.githubusercontent.com/43739827/73734050-5ecb7700-4780-11ea-8c30-f190ed8be779.png"></img>  

axis=1을 지정하면 행을 고정하고 열의 모든 원소를 전부 계산하라는 뜻이다. 이 데이터 프레임은 2행 4열이므로 두 개의 행을 기준으로 열의 합산을 계산해서 결과를 내는 것을 알 수 있다.  

* 수학 연산 시 처리 규칙  
데이터 프레임 객체에 연산을 하면 단항(Unary) 연산자는 주로 하나의 객체를 처리하므로 내부에 지정된 행과 열에 대한 레이블을 유지하지만 이항(binary) 연산자는 두 개의 객체를 처리하므로 행과 열의 레이블을 정렬(alignment)해서 비교한 후에 계산하므로 레이블이 정렬되어 처리된다.  

* 내부 원소에 대한 정렬  
데이터 프레임을 만들 때 수학 연산이 발생하는 경우 단항 연산자와 이항 연산자들이 처리되는 결과를 확인한다.  

<img width="1086" alt="40" src="https://user-images.githubusercontent.com/43739827/73735284-61c76700-4782-11ea-9551-e6895cee596c.png"></img>  

numpy 모듈을 이용하여 1부터 10까지의 숫자를 가지고 3행 3열의 배열을 만들고 데이터 프레임으로 정의한다. 행의 레이블은 암묵적으로 처리되도록 지정하지 않았고, 열의 레이블을 A, B, C로 부여한다. 처리 결과를 보면 데이터 프레임도 3행 3열로 구성되고 행과 열의 레이블이 표시된 것을 알 수 있다.  

<img width="1086" alt="41" src="https://user-images.githubusercontent.com/43739827/73735820-309b6680-4783-11ea-8fcd-f07e334e0185.png"></img>  

<img width="1084" alt="42" src="https://user-images.githubusercontent.com/43739827/73736026-7b1ce300-4783-11ea-98f0-f2ba75ec4134.png"></img>  

또 다른 데이터 프레임 객체를 만들었다. numpy의 log 함수를 이용해서 데이터 프레임을 계산하면 현재 정의된 레이블은 유지되면서 계산된 결과에 새로운 데이터 프레임 객체를 반환한다.  

<img width="1086" alt="43" src="https://user-images.githubusercontent.com/43739827/73736488-2ded4100-4784-11ea-9b29-49b66fafd2a2.png"></img>  

두 개의 데이터 프레임에 덧셈 연산인 즉 이항 연산자의 연산을 하면 행과 열의 레이블을 맞춰 정렬하여 계산한 후에 정렬된 데이터 프레임 객체를 반환한다.  

<img width="1085" alt="44" src="https://user-images.githubusercontent.com/43739827/73736684-8fadab00-4784-11ea-8452-94ce840943e1.png"></img>  

<img width="1082" alt="45" src="https://user-images.githubusercontent.com/43739827/73736785-c1bf0d00-4784-11ea-9dae-20d97458efaf.png"></img>  

이번에는 두 개의 열만을 갖는 데이터 프레임을 생성한다. 이를 이전에 만들어진 df_1 데이터 프레임과 연산하면 정렬을 처리해서, 만들어질 때 없었던 A열의 값이 NaN으로 처리된다. 이때 NaN으로 계산되는 결과는 항상 NaN이므로 A열의 값이 전부 NaN으로 처리되는 것을 알 수 있다.  

* 파일 처리 및 한글 인코딩  
판다스에서는 다양한 파일을 읽어서 데이터 프레임으로 변환하는 일이 많다. 특히 csv 파일을 읽어서 데이터 프레임으로 바로 변환하여 처리하는 방법이 아주 편하게 사용되기도 한다. 파일 안의 문자열이 한글일 때 파이썬은 utf-8로 인코딩을 처리한 후에 데이터 프레임으로 전환해야 한다.

한글을 사용하는 경우에는 완성형과 조합형으로 되어 있을 때가 많다. 이중에 완성형에서는 각 솔루션별로 다른 인코딩을 사용하므로 한글 인코딩도 작성된 솔루션에 맞춰 처리해야 한다.

파일을 읽고 그 파일이 어떤 형태로 한글 인코딩되는지를 알아볼 필요가 있다. 이때 다른 파이썬 모듈인 chardet 모듈을 추가 설치해주어야 한다.  

<img width="890" alt="46" src="https://user-images.githubusercontent.com/43739827/73739334-5deb1300-4789-11ea-8f5d-570b804d4700.png"></img>

이 모듈이 설치된 후에 import하고 읽어온 파일을 열어 이 파일이 어떤 인코딩으로 처리되는지를 확인한다. detect 메소드로 이 파일의 정보를 읽은 후 result 변수에 'encoding'속성을 확인해 인코딩 방식을 조회할 수 있다.  

판다스 모듈의 .read_csv 함수에 하나의 csv 파일에 있는 path를 넣고 open 한다. encoding 매개변수에 find_encoding 함수에서 실행된 결과인 인코딩 정보를 가져와서 실행하면 데이터 프레임이 하나 만들어진다. 그리고 실제 인코딩한 정보를 저장한 my_encoding 변수를 출력하면 인코딩 정보가 출력되는것을 확인할 수 있다. 인코딩으로 들어올 매개변수가 다를 경우 예외도 발생할 수 있다.  

<img width="892" alt="47" src="https://user-images.githubusercontent.com/43739827/73739634-fb464700-4789-11ea-8283-34c2f1ddd10b.png"></img>  

이 파일은 읽어온 것을 df_1 변수에 할당했으므로 이중에 앞에 있는 것을 head 메소드로 조회하면 이 데이터 프레임에 위의 5개까지 출력하는 것을 볼 수 있다. 이 파일은 열 이름은 한글이고 내부의 데이터도 한글로 처리된 것을 확인 할 수 있다. 이 파일은 열 이름은 한글이고 내부의 데이터도 한글로 처리된 것을 확인 가능하다.  

<img width="884" alt="48" src="https://user-images.githubusercontent.com/43739827/73740179-077ed400-478b-11ea-886e-1ee44a0eed59.png"></img>  

head에 특정 값을 입력하면 맨 위 행에서 특정값을 위치로하는 행까지 보여준다.  

<img width="885" alt="49" src="https://user-images.githubusercontent.com/43739827/73740640-e36fc280-478b-11ea-98a2-a927f82be885.png"></img>  

특정 열의 삭제하고 싶다면 .drop메소드에 그 열의 이름과 axis=1을 입력하면 삭제할 수 있다.
