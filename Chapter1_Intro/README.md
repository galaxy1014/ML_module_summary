Introduction
============

판다스는 파이썬의 데이터 분석 라이브러리로써 행과 열로 이루어진 테이블형태의 데이터를 관리하는데에 사용된다.

## 1. 판다스의 특징

* 데이터 그룹화   
 테이블의 열을 그룹화하거나 여러 개의 데이터 프레임들을 하나로 통합하여 하나의 정보로 요약할 수 있다.

* 데이터 분석 및 시각화  
 데이터의 수치화가 간편하며 이것을 그래프로 시각화할 수 있다. 또한 판다스의 데이터 프레임(Data Frame)은 하나의 자료형만을 가지게 되는데 이것은 데이터 분석에 필요한 변수를 구성하는 기본 조건을 만족한다.  
 데이터 분석에서의 변수분류 방법은 수치형과 텍스트형이 있으며 수치형은 연속형(주어진 일정 범위의 실수)과 정수형(정수값)을 구분하며 텍스트형에는 일반 텍스트와 일정 범위를 가진 범주형으로 나뉘어진다.  

 <img width="396" alt="0" src="https://user-images.githubusercontent.com/43739827/73828871-5ee17a80-4845-11ea-91fd-cc84fa1ee67b.png"></img>  


## 2. 클래스

판다스는 넘파이 모듈을 기반으로 만들어졌기 때문에 넘파이 기본연산을 모두 제공한다. 그러나 판다스는 넘파이와 달리 행(Row)과 열(Column)에 각각 라벨링하기 때문에 각 열의 타입이 달라도 된다. 이는 내부 요소들에 빠르게 접근하기 위함이다.  

<img width="1079" alt="1-1" src="https://user-images.githubusercontent.com/43739827/73830606-49ba1b00-4848-11ea-8ffe-dd44fb9a6a7e.png"></img>  
> Number의 Column을 보면 전부 정수형이 아닌것을 확인 할 수 있다.  

* 연산자와 메소드
판다스에서 클래스를 만들 때에 numpy의 배열인 ndarray를 이용한다. 그렇기 때문에 넘파이 모듈과 판다스의 선언 형식을 보면 상당히 비슷함을 알 수 있다.   

<img width="1080" alt="1-2" src="https://user-images.githubusercontent.com/43739827/73831111-1deb6500-4849-11ea-8ca8-799fc38cb721.png"></img>  
> 시리즈와(Series)와 ndarray의 선언 방식 비교

**시리즈(Series)** 는 1차원 벡터로 파이썬에서의 리스트를 입력하면 생성된다. 또한 레이블을 붙여 인덱스를 활용할 수 있으며 암묵적인 숫자 타입의 인덱스도 실행 가능하다.  

<img width="1084" alt="1-3" src="https://user-images.githubusercontent.com/43739827/73832533-b08d0380-484b-11ea-81fd-1b58b56940e1.png"></img>
> 실행결과와 같이 자료형을 지정하지 않을 때는 내부적으로 원소 값을 확인하여 추론해 가장 적절한 자료형을 선택한다.

시리즈에 덧셈 연산자(+)를 사용하여 계산한 결과는 시리즈로 반환된다. 이유는 판다스 모듈의 기본 원칙이 원래의 시리즈 값을 바꾸지 않고 새롭게 만들어 반환하는 것이기 때문이다.

<img width="1085" alt="1-4" src="https://user-images.githubusercontent.com/43739827/73833036-a7506680-484c-11ea-8db4-7d60ed07202d.png"></img>
> 시리즈의 값에 변화가 없는것을 확인할 수 있다.  

덧셈 연산자 이외에도 .add()메소드를 사용하면 동일한 결과를 출력할 수 있다.  

<img width="1082" alt="1-5" src="https://user-images.githubusercontent.com/43739827/73833195-e8e11180-484c-11ea-97aa-7d331ff08679.png"></img>
> 시리즈 + 시리즈 == 시리즈.add(시리즈)  

* 검색과 슬라이싱  
위에서 사용했던 시리즈를 가지고 데이터 프레임을 만들었다. 만들 때에 아무런 조건을 설정하지 않았으나 출력된 결과물을 확인해보면 자동으로 행과 열에 라벨링이 되어있다. 이처럼 아무런 조건을 지정하지 않았을때는 0부터 시작하는 정수형으로 자동 설정된다.    

<img width="1083" alt="1-6" src="https://user-images.githubusercontent.com/43739827/73833543-7a508380-484d-11ea-8cf4-5274e6d51dca.png"></img>  
> 행과 열에 0부터 시작하는 정수가 라벨링되어진것을 확인할 수 있다.

데이터 프레임의 열(Column)의 레이블이 0으로 되어있기에 검색조건을 **Df[0]** 으로하면 출력결과가 시리즈인 것을 확인할 수 있다. 이것은 데이터프레임은 2차원으로 구성되어있기 때문에 1차원 낮은 시리즈로 검색된 것이다.

<img width="1082" alt="1-7" src="https://user-images.githubusercontent.com/43739827/73834205-a6203900-484e-11ea-8a04-7d431c80abd6.png"></img>  
> 데이터 프레임의 검색기준은 항상 열이다. 슬라이싱은 행을 기준으로 하기 때문에 두가지에 대해서 확실하게 ] 알 필요가 있다.  

데이터 프레임을 검색하면 name이라는것이 함께 출력되는 것을 확인할 수 있다. name은 조회하는 열의 레이블을 나타내며 만약 데이터 프레임을 생성했을때 레이블을 설정했었다면 그 레이블을 검색 조건으로 지정해야 한다. 만약 레이블로 지정되지 않은 값을 검색조건으로 했을 때엔 **KeyError** 가 발생하게 된다.

<img width="1084" alt="1-9" src="https://user-images.githubusercontent.com/43739827/73835258-72461300-4850-11ea-8faa-2b1d22089256.png"></img>  


행을 검색하기 위해서는 iloc 인덱서를 사용한다. 실제 데이터 프레임의 행의 레이블은 순서와 상관없이 생성해도 되므로 실제 레이블을 검색하는 .loc 속성과 암묵적인 인덱스로 검색하는 .iloc 두 가지를 제공한다.  
행을 기준으로 검색하기 위해서는 **.loc** 혹은 **.iloc** 을 사용해야 한다. 두 함수의 차이는 loc은 인덱스를 기준으로 행을 읽어들이지만 iloc은 실제 행 번호를 기준으로 읽어들인다는 것이다.  

<img width="1087" alt="1-10" src="https://user-images.githubusercontent.com/43739827/73835848-7b83af80-4851-11ea-96a0-75584e4e0815.png"></img>
> .loc은 인덱스를 기준으로 데이터를 읽어들이기 때문에 행 번호나 인덱스가 아닌 값을 입력하면 오류가 발생한다.

<img width="1085" alt="1-11" src="https://user-images.githubusercontent.com/43739827/73836050-cef5fd80-4851-11ea-8aa1-f1fbbb6d3c03.png"></img>  
> .iloc은 행 번호를 기준으로 하기 때문에 데이터 프레임의 가장 마지막 행을 검색하고자 한다면 파이썬의 리스트처럼 [-1]을 해주면 된다.  

행 단위의 검색 또한 열 단위 검색과 마찬가지로 시리즈가 반환되는것을 확인할 수 있다. 만약 차원을 축소하여 데이터를 검색하고자 한다면 .iloc 함수에 특정 행과 열을 입력한다. 혹은 파이썬의 리스트와 마찬가지로 행,열을 연속으로 호출해도 동일한 결과를 보여준다.

<img width="1084" alt="1-12" src="https://user-images.githubusercontent.com/43739827/73836512-c651f700-4852-11ea-8639-0eb05d0124d7.png"></img>
> .iloc 함수를 사용하지 않은 일반적인 호출을 할 때엔 검색기준이 ['열(Column) 조건']['행(Row) 조건']임을 명심한다.   

* 데이터 구조의 편리성

시리즈와 데이터 프레임에는 다양한 속성들이 있다. 이 속성들을 이용해 직접적인 접근이나 다른 메소드를 활용한 접근도 가능하다.  
<img width="1438" alt="1-13" src="https://user-images.githubusercontent.com/43739827/73837054-f64dca00-4853-11ea-8113-e8131fb4fc23.png"></img>
> 판다스 공식 사이트에서 속성들에 대한 정보들을 확인할 수 있다. [pandas DOCS](https://pandas.pydata.org/docs/reference/series.html, "DOCS link")  


* 행과 열에 대한 인덱스 정보 관리

판다스의 내부 요소들에 접근할 수 있는 인덱스는 별도의 클래스다. 인덱스란 내부 요소들을 별도로 관리하면서 정보를 연결해 특정 원소 값과 부분 집합을 처리할 수 있는 구조이다. 이 때의 데이터 처리는 넘파이를 이용하기 때문에 넘파이 모듈과의 연계성을 그대로 유지한다.

데이터 프레임을 만들기 위해서는 기본적으로 행,열,데이터 3개의 매개변수가 요구된다. 그렇지만 행과 열을 별도로 입력하지 않았을때는 0부터 시작하는 정수가 자동적으로 입력된다. 데이터 프레임의 생성 결과를 확인해 보면 설정한 행과 열의 레이블이 지정되어있고 내부 원소들이 data로 입력한 값임을 확인할 수 있다.

<img width="1085" alt="1-14" src="https://user-images.githubusercontent.com/43739827/73837721-614bd080-4855-11ea-8d14-2ca5fdad1fed.png"></img>  
> 행(index)과 열(column)을 지정하는 방식이 다르지만 실제론 같은 의미이미로 둘 중 아무렇게나 사용해도 상관없다.    

레이블을 관리하는 index와 columns의 속성은 indexes 클래스의 인스턴스, 내부 원소들을 관리하는 속성은 넘파이의 ndarray임을 확인할 수 있다.  

<img width="1082" alt="1-15" src="https://user-images.githubusercontent.com/43739827/73838145-58a7ca00-4856-11ea-9325-134fed5e49e9.png"></img>
> type 클래스는 내부 정보를 사용자들이 편하게 볼 수 있게끔 하는 역할을 한다.  

* 인스턴스 관리 기준  
판다스는 파이썬에서 클래스를 이용해 인스턴스를 만드는 것과 같다. 차이점은 판다스는 연산을 처리할때 내부의 요소들을 갱신하는것이 아니라 새로운 인스턴스를 만들어 반환한다는 것이다. 만약 기존의 값을 갱신하고자 한다면 메소드 내에서 조건을 지정하여 처리해야 한다. 판다스가 이런 규칙을 고집하는 이유는 대용량 처리를 하기 위해서는 기존 값들의 갱신보다는 새로운 인스턴스를 만들어 반환하는 것이 훨씬 빠르기 때문이다.  

* 변수를 할당할 경우 항상 별칭(alias)으로 사용  
데이터 프레임을 생성해 변수에 할당하고, 할당된 데이터 프레임의 값을 변경하면 원본 데이터 프레임의 값도 갱신된다.  

<img width="1084" alt="1-16" src="https://user-images.githubusercontent.com/43739827/73838958-37e07400-4858-11ea-9532-0bbbc101b553.png"></img>
> 3X3의 각 요소의 값이 다른 데이터 프레임 df를 생성하여 df_a에도 할당하였다. 그 후 1열의 값을 100을 주어 df_a의 값이 갱신된것을 확인하고 원본 데이터 프레임인 df의 값이 갱신된것을 확인하였디.

<img width="1087" alt="1-17" src="https://user-images.githubusercontent.com/43739827/73839242-d8cf2f00-4858-11ea-9a3f-2e03e6e4a237.png"></img>  
> df와 df_a의 id를 확인해보면 같음을 확인할 수 있다. 할당이란 별도로 사본을 만드는것이 아닌 원본을 참조하는 것이기 때문에 마치 데이터베이스의 CASCADE처럼 값을 수정하면 똑같이 변경되는것을 확인할 수 있다.  

* 연산된 결과는 항상 새로운 인스턴스로 반환
위에서 생성한 데이터프레임 df를 같은 값으로 한 번더 더하여 df_b라는 변수에 할당해주었다. 그 후 df_b와 df의 id를 확인했을때 서로 다름을 확인할 수 있다. 이러한 이유는 판다스의 연산은 새롭게 사본을 만들어 반환하므로 변수에 할당하면 새로운 객체가 지정되기 때문이다. 실제로 df의 값들은 변하지 않았음을 확인할 수 있다.

<img width="1084" alt="1-18" src="https://user-images.githubusercontent.com/43739827/73839746-13859700-485a-11ea-9e1c-9a76dab4695e.png"></img>  

시리즈도 데이터 프레임과 같은 방식을 사용하는지 확인하고자 한다. 넘파이를 활용한 0~6까지의 정수로 채운 시리즈를 하나 만들어 se_1이라 부른다. 이것을 se_2에 할당하고 se_2의 특정 값을 변경하면 원본인 se_1에도 변화가 생긴것을 확인할 수 있다.  

<img width="1083" alt="1-19" src="https://user-images.githubusercontent.com/43739827/73840631-edf98d00-485b-11ea-962a-dd4ac5e49bfe.png"></img>

이번에는 se_1의 사본을 만들어 se_3에 입력한다. se_3의 특정 값을 변경해도 원본인 se_1에는 아무런 변화가 없음을 확인할 수 있다.  

<img width="1086" alt="1-20" src="https://user-images.githubusercontent.com/43739827/73840828-6d875c00-485c-11ea-8814-1660412b4dac.png"></img>

* 인덱스 검색과 슬라이싱 처리  
판다스에서의 인덱스 검색과 슬라이싱은 대괄호연산([]) 및 마스킹(masking) 검색, 팬시(fancy) 검색 등이 추가되었다. 또한 속성인 인덱서(indexer)라는 개념도 추가되어 행 중심으로 검색하는 기능도 지원한다. 어떤 경우라도 대괄호 연산을 이용하려면 스페셜 메소드인 **__getitem__** 가 존재해야 한다.

<img width="1085" alt="1-21" src="https://user-images.githubusercontent.com/43739827/73841145-47ae8700-485d-11ea-92b2-d35258c4c1e6.png"></img>  

판다스에서는 파이썬처럼 클래스의 인스턴스 메소드가 함수로 유지되는 것을 알 수 있다. 그리고 실제 인스턴스 개체와 메소드가 바인딩되면 메소드로 실행되는 것도 볼 수 있다.

<img width="1100" alt="1-22" src="https://user-images.githubusercontent.com/43739827/73841492-24d0a280-485e-11ea-9e95-a41c6940475c.png"></img>  

데이터 프레임의 인덱스를 검색해보면 파이썬과 달리 열 단위를 기준으로 처리하는 것을 확인해볼 수 있다. 또한 스페셜 메소드에 인자를 넣고 검색해도 동일한 결과가 나오는 것을 확인할 수 있는데 이는 실제 연산자들이 모두 스페셜 메소드를 변환한것임을 알 수 있다.  

<img width="1090" alt="1-23" src="https://user-images.githubusercontent.com/43739827/73841813-b50ee780-485e-11ea-9055-78c0cf7f10c4.png"></img>  

생성한 데이터 프레임의 한 열을 다른 변수에 할당해주면 시리즈가 되는것을 확인할 수 있다. 또한 만들어진 시리즈의 인덱스 검색 연산자와 스페셜 메소드 검색 연산 결과가 동일함을 확인할 수 있다.  

<img width="1096" alt="1-24" src="https://user-images.githubusercontent.com/43739827/73842103-43836900-485f-11ea-919c-552c38c53298.png"></img>

판다스는 파이썬과 다르게 테이블 이름으로 인덱스 검색이 가능하다. 또한 논리식을 사용하여 조건에 합당하는 값들만 가지고 올 수도 있다. 만약 이 조건에 부합하지 않는다면 이를 **False** 로 간주하고 존재하지 않는 값으로 처리하기 위해 NaN으로 처리된다.  

<img width="1093" alt="1-25" src="https://user-images.githubusercontent.com/43739827/73842789-9d386300-4860-11ea-84cd-1d39c81db062.png"></img>
> 구체적인 행과 열을 지정하지 않고 단순하게 테이블 이름을 검색 조건으로 지정하면 된다.  

## 3. 메소드 & 함수

판다스는 대용량의 데이터를 처리하기 위해 loop를 사용하지 않고 모양이나 차원이 다른 경우에 브로드캐스팅을 해서 모양을 맞추고 계산한다. 또한 데이터가 없더라도 내부적으로 예외를 발생시키지 않고 데이터를 처리하면 각 차원별로 계산이 가능하다.  

* 브로드캐스팅 및 벡터와 연산  

브로드캐스팅이란 원소의 개수가 맞지 않는 시리즈나 데이터 프레임간의 연산을 위해 모양을 맞춰주는 것을 말하며 이를 한 번에 연산처리하는것을 벡터화 연산(vectorizing)이라고 한다. loop를 사용하지 않는 이유는 시리즈나 데이터 프레임이 다차원 데이터이기 때문에 내부에서 각 원소별로 처리하는 것이 더 편하기 대문이다.

<img width="1097" alt="1-26" src="https://user-images.githubusercontent.com/43739827/73843930-f1444700-4862-11ea-97fe-bdecff46523c.png"></img>  
> 4행 3열의 테이블에 [10, 20, 30]의 리스트를 곱하였다. 이때 사용되는 것이 브로드캐스팅이다.  

브로드캐스팅은 넘파이에서 사용되는 기법이다. 만약 다른 모양의 배열끼리의 연산을 하고자하면 이 브로드캐스팅에 관련된 오류가 나타난다.  

<img width="1077" alt="1-28" src="https://user-images.githubusercontent.com/43739827/73929310-e7c8e680-4917-11ea-89ac-f1f924f0e6da.png"></img>

브로드캐스팅은 특정 조건을 만족하면 자동적으로 배열의 모양을 맞춰주는 것이다. 이 조건으로는  
1. 두 배열간의 연산에서 적어도 하나가 1차원 배열 즉, 행이나 열이 1개라면 가능하다.  
2. 차원 간의 축의 길이가 동일할때 가능하다.

<img width="1077" alt="Broadcasting" src="https://user-images.githubusercontent.com/43739827/73929653-8fdeaf80-4918-11ea-8634-a5f19659e9b4.png"></img>  
> [이미지 출처 링크](https://pandas.pydata.org/docs/reference/series.html, "DOCS link")   

시리즈와 데이터 프레임은 다차원으로 이루어져 있으므로 이것들을 계산하기 위해서는 각 원소의 개수를 차원 단위로 맞춰야 한다. 3 X 3에 index가 정해져있는 데이터 프레임 Df를 생성하고 3 X 3에 columns가 정해져있는 데이터 프레임 Df_2를 생성하였다.  

<img width="1083" alt="1-29" src="https://user-images.githubusercontent.com/43739827/73931082-08467000-491b-11ea-8b72-e52c42b0fcf1.png"></img>  

Df에 상수(Constant) 3을 더하면 각 요소에 3씩 값이 증가한것을 확인할 수 있다.
<img width="1085" alt="1-30" src="https://user-images.githubusercontent.com/43739827/73931283-5eb3ae80-491b-11ea-939c-e10e1a1b5bc7.png"></img>  
> 상수값인 3이 3 X 3의 데이터 프레임으로 브로드캐스팅되어 연산된 결과이다.  

Df 와 Df_2를 더하고자 했을 때 이상한 형태의 데이터 프레임이 반환되는것을 확인할 수 있다. 이는 Df가 index를 Df_2가 columns를 고정하고 있기 때문에 서로 동일하지 않아 브로드캐스팅이 일어나지 않은 것이다. Df를 columns를 고정하는 데이터프레임으로 고정하고 다시 더하기 연산을 수행하면 원하던 결과를 보여주는것을 확인할 수 있다.  

<img width="1085" alt="1-31" src="https://user-images.githubusercontent.com/43739827/73931443-aa665800-491b-11ea-98ee-9fd78ce7174b.png"><img>


파이썬에서는 덧셈 연산을 스페셜 메소드인 **__add__** 를 지원한다. 판다스는 추가적으로 **add** 라는 메소드또한 지원한다. 이 두 메소드의 기능은 동일하다.  

<img width="1085" alt="1-32" src="https://user-images.githubusercontent.com/43739827/73932338-7724c880-491d-11ea-896e-6b21481c6144.png"></img>  
> 판다스가 스페셜 메소드와 일반 메소드 두 가지를 제공하는 이유는 다양한 매개변수를 메소드에 넣어 기능을 확장하기 위함이다. 이 두 메소드 내부의 함수가 동일한지를 확인해보면 서로 다른것을 볼 수 있다. 두 함수의 차이는 매개변수가 어떻게 얼마나 들어가는가이다.

* 누락 값을 포함한 데이터 처리  
판다스의 특징은 실제 원소값이 들어있지 않더라도 예외시키지 않고 처리하는 것이다. 판다스는 비어있는 값을 표현할때 넘파이 모듈의 np.nan을 의미하는 NaN으로 표시한다. 만약 연산하고자 하는 데이터 프레임의 요소에 NaN이 들어있을 경우 이를 제외하고 연산을 수행한다. 이 NaN은 논리식에서 항상 False값을 반환한다.    

데이터 프레임을 생성하고 요소중 하나를 NaN처리한다. 이 NaN값은 판다스에서는 float으로 처리하기 때문에 자료형이 float64이다.  

<img width="1085" alt="1-33" src="https://user-images.githubusercontent.com/43739827/73932849-83f5ec00-491e-11ea-8de2-bd6b5ff6b9a9.png"></img>
> 데이터 프레임의 열을 뽑아내 정보를 확인하면 float64인것을 확인할 수 있다.  

**.sum** 메소드는 데이터 프레임 내부의 모든 원소를 더한 값을 한 차원 축소하여 반환한다. 이 때 요소중 NaN값이 있다면 이 값을 생략한채로 계산한다. 만약 생략하지 않은채로 모든 원소를 계산하고 싶다면 .sum 메소드에 **skipna=True** 를 지정해준다. 그러나 이 때의 결과는 NaN으로 처리된다.

<img width="1088" alt="1-34" src="https://user-images.githubusercontent.com/43739827/73932973-cfa89580-491e-11ea-997b-38820bbc6c10.png"></img>  

데이터 프레임에 비교 연산자를 사용하면 그 조건에 부합하는 요소는 True로, 부합하지 못한 요소는 False로 처리된다. 만약 비교 조건으로 NaN을 사용한다면 NaN이 들어있는 요소도 False로 출력되는것을 확인할 수 있다. 즉, 누락 값은 비교연산에 사용할 수 없음을 나타낸다.  

<img width="1083" alt="1-35" src="https://user-images.githubusercontent.com/43739827/73933302-80169980-491f-11ea-9b44-ebb629321463.png"></img>  


## 4.축  

* 축  
판다스에서는 다차원 계산을 처리할때 축을 기준으로 연산한다. 1차원인 시리즈는 축이 하나만 있기 때문에 축은 0이며 2차원인 데이터 프레임은 행 = 0, 열 = 1로 되어있다. 보통 1차원일 때 0(=행, row, index)만 있고 2차원일 때 0과 1만 가진다. 원소들을 계산할 때는 0축은 각 열(=1, column)에 대한 행의 원소들을 계산하고 1축은 각 행(=0, index)에 대한 열의 원소들을 계산 한다.  

<img width="641" alt="34" src="https://user-images.githubusercontent.com/43739827/73732730-072c0c00-477e-11ea-8c30-6a421d0c1dd1.png"></img>  
> 행과 열은 각각 axis=0과 axis=1을 의미한다. 계산할 때는 axis를 주고 그 축에 대한 고정을 지정하면, 고정된 축을 기준으로 내부의 값들이 계산된다.  

생성된 시리즈에 **.sum(axis=0)** 를 하였다. 이는 행을 고정하여 그 내부의 원소를 모두 더하라는 뜻이다. 이 연산의 결과는 정수로 반환된다.  

<img width="1078" alt="1-36" src="https://user-images.githubusercontent.com/43739827/73933926-d3d5b280-4920-11ea-98de-a56bf158dce2.png"></img>

2 X 5의 행과 열이 지정된 데이터 프레임을 생성하였다. .sum 메소드에 **axis=0** 을 입력한 결과를 확인해보면 열을 기준으로 계산된 것을 확인할 수 있다. **axis=1** 을 입력했을 때에는 행을 기준으로 계산한 것을 확인할 수 있다.

<img width="1087" alt="1-37" src="https://user-images.githubusercontent.com/43739827/73934590-15b32880-4922-11ea-9572-f1f4c36af93f.png"></img>  

* 수학 연산 시 내부 원소에 대한 정렬  
데이터 프레임에 단항 연산을 하면 하나의 객체를 처리하기 때문에 내부에 지정된 행과 열에 대한 레이블을 유지하지만 이항 연산자의 경우 두 개의 객체를 처리하기 때문에 레이블이 정렬되어 비교한 후 계산되기 때문에 레이블의 정렬을 확인할 수 있다.

넘파이 모듈을 이용해 1부터 20까지의 난수로 채워진 5 X 5의 데이터 프레임 df_sample을 생성하였다. 행은 따로 지정하지 않았으며 열은 A부터 E까지 알파벳순으로 되어있다. 또한 1부터 40까지의 난수로 채워진 5 X 5의 데이터 프레임 df_sample2를 생성하였다. 이 데이터 프레임은 행은 따로 지정되어있지 않고 열은 D, A, B, E, C로 알파벳순과는 무관하게 설정되어 있다.

<img width="1088" alt="1-38" src="https://user-images.githubusercontent.com/43739827/73936307-df77a800-4925-11ea-81aa-3f5bddac5a3e.png"></img>  

로그값을 출력하는 np.log에 df_sample2를 넣어 결과를 확인해보면 레이블은 초기에 설정했던 순서대로 있는것을 볼 수 있다. 그러나 df_sample과 df_sample2를 덧셈연산 해보면 행과 열의 레이블이 맞추어져 정렬되는것을 확인할 수 있다.

<img width="1086" alt="1-39" src="https://user-images.githubusercontent.com/43739827/73936474-46955c80-4926-11ea-8632-cf4d35025d9d.png"></img>  

3 X 3의 1부터 20까지 난수를 가지는 데이터 프레임 df_sample3를 생성하였다. 행은 설정하지 않고 열은 B, C, D로 지정되어 있다. 이 데이터 프레임을 df_sample과 덧셈 연산한 결과를 보면 df_sample3에는 없는 행과 열이 NaN으로 처리되어 df_sample의 크기와 같은 5 X 5의 데이터 프레임이 반환되는것을 확인할 수 있다.  

<img width="1085" alt="1-40" src="https://user-images.githubusercontent.com/43739827/73936797-f074e900-4926-11ea-8db0-431cfbb43c17.png"></img>  


* 파일 처리 및 한글 인코딩  
파일을 읽고 그 파일이 어떤 형태로 한글 인코딩되는지를 알아볼 필요가 있다. 이때 다른 파이썬 모듈인 chardet 모듈을 추가 설치해주어야 한다.  
판다스를 이용해 데이터 분석을 할때 csv로 파일을 읽어 데이터 프레임으로 변환하는 방법이 자주 사용된다. 이때 인코딩에 신경을 써야하기 때문에 파일의 인코딩 형태를 알 필요가 있다. 이를 위해서 파이썬 모듈인 chardet을 설치해준다. chardet의 **.detect()** 메소드는 파일의 정보를 읽어들이는 기능을 한다.  

find_encoding()은 그 path에 있는 파일의 인코딩 정보를 .read_csv()는 path에 있는 csv파일을 encoding정보대로 읽어들인다. 만약 인코딩으로 들어올 매개변수가 다를 경우에는 예외도 발생할 수 있다.  

<img width="890" alt="46" src="https://user-images.githubusercontent.com/43739827/73739334-5deb1300-4789-11ea-8f5d-570b804d4700.png"></img>

불러온 파일은 df_1에 데이터 프레임으로 저장되어 있다. 이를 .head 메소드로 조회하면 상위 5개 행을 보여주는것을 볼 수 있는데 head 메소드는 **head(self, n=5)** 로 되어있어 n값을 따로 설정해주지 않았다면 5행까지 출력되기 때문이다. 또한 테이블의 열과 내부 데이터가 한글로 되어있는것을 알 수 있다.  

<img width="892" alt="47" src="https://user-images.githubusercontent.com/43739827/73739634-fb464700-4789-11ea-8283-34c2f1ddd10b.png"></img>  
<img width="207" alt="1-41" src="https://user-images.githubusercontent.com/43739827/73937554-a68d0280-4928-11ea-862a-657df5a90f17.png"></img>  
> 판다스로 읽어들인 테이블과 원본 테이블 비교  

head에 특정 값을 입력하면 맨 위 행에서 처음 n줄의 데이터를 출력한다.

<img width="884" alt="48" src="https://user-images.githubusercontent.com/43739827/73740179-077ed400-478b-11ea-886e-1ee44a0eed59.png"></img>  
> head 메서드는 객체 안에 제대로된 데이터 타입이 입력되어있는가를 빠르게 확인할 때 유용하게 사용할 수 있다.  

특정 열의 삭제하고 싶다면 .drop메소드에 그 열의 이름과 axis=1을 입력하면 삭제할 수 있다.

<img width="885" alt="49" src="https://user-images.githubusercontent.com/43739827/73740640-e36fc280-478b-11ea-98a2-a927f82be885.png"></img>  
