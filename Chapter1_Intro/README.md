Introduction
============

판다스는 파이썬의 데이터 분석 라이브러리로써 행과 열로 이루어진 테이블형태의 데이터를 관리하는데에 사용된다.

## 1. 판다스의 특징

* 데이터 그룹화   
 테이블의 열을 그룹화하거나 여러 개의 데이터 프레임들을 하나로 통합하여 하나의 정보로 요약할 수 있다.

* 데이터 분석 및 시각화  
 데이터의 수치화가 간편하며 이것을 그래프로 시각화할 수 있다. 또한 판다스의 데이터 프레임(Data Frame)은 하나의 자료형만을 가지게 되는데 이것은 데이터 분석에 필요한 변수를 구성하는 기본 조건을 만족한다.  
 데이터 분석에서의 변수분류 방법은 수치형과 텍스트형이 있으며 수치형은 연속형(주어진 일정 범위의 실수)과 정수형(정수값)을 구분하며 텍스트형에는 일반 텍스트와 일정 범위를 가진 범주형으로 나뉘어진다.  

 <img width="396" alt="0" src="https://user-images.githubusercontent.com/43739827/73828871-5ee17a80-4845-11ea-91fd-cc84fa1ee67b.png"></img>  


## 2. 클래스

판다스는 넘파이 모듈을 기반으로 만들어졌기 때문에 넘파이 기본연산을 모두 제공한다. 그러나 판다스는 넘파이와 달리 행(Row)과 열(Column)에 각각 라벨링하기 때문에 각 열의 타입이 달라도 된다. 이는 내부 요소들에 빠르게 접근하기 위함이다.  

<img width="1079" alt="1-1" src="https://user-images.githubusercontent.com/43739827/73830606-49ba1b00-4848-11ea-8ffe-dd44fb9a6a7e.png"></img>  
> Number의 Column을 보면 전부 정수형이 아닌것을 확인 할 수 있다.  

* 연산자와 메소드
판다스에서 클래스를 만들 때에 numpy의 배열인 ndarray를 이용한다. 그렇기 때문에 넘파이 모듈과 판다스의 선언 형식을 보면 상당히 비슷함을 알 수 있다.   

<img width="1080" alt="1-2" src="https://user-images.githubusercontent.com/43739827/73831111-1deb6500-4849-11ea-8ca8-799fc38cb721.png"></img>  
> 시리즈와(Series)와 ndarray의 선언 방식 비교

** 시리즈(Series) ** 는 1차원 벡터로 파이썬에서의 리스트를 입력하면 생성된다. 또한 레이블을 붙여 인덱스를 활용할 수 있으며 암묵적인 숫자 타입의 인덱스도 실행 가능하다.  

<img width="1084" alt="1-3" src="https://user-images.githubusercontent.com/43739827/73832533-b08d0380-484b-11ea-81fd-1b58b56940e1.png"></img>
> 실행결과와 같이 자료형을 지정하지 않을 때는 내부적으로 원소 값을 확인하여 추론해 가장 적절한 자료형을 선택한다.

시리즈에 덧셈 연산자(+)를 사용하여 계산한 결과는 시리즈로 반환된다. 이유는 판다스 모듈의 기본 원칙이 원래의 시리즈 값을 바꾸지 않고 새롭게 만들어 반환하는 것이기 때문이다.

<img width="1085" alt="1-4" src="https://user-images.githubusercontent.com/43739827/73833036-a7506680-484c-11ea-8db4-7d60ed07202d.png"></img>
> 시리즈의 값에 변화가 없는것을 확인할 수 있다.  

덧셈 연산자 이외에도 .add()메소드를 사용하면 동일한 결과를 출력할 수 있다.  

<img width="1082" alt="1-5" src="https://user-images.githubusercontent.com/43739827/73833195-e8e11180-484c-11ea-97aa-7d331ff08679.png"></img>
> 시리즈 + 시리즈 == 시리즈.add(시리즈)  

* 검색과 슬라이싱  
위에서 사용했던 시리즈를 가지고 데이터 프레임을 만들었다. 만들 때에 아무런 조건을 설정하지 않았으나 출력된 결과물을 확인해보면 자동으로 행과 열에 라벨링이 되어있다. 이처럼 아무런 조건을 지정하지 않았을때는 0부터 시작하는 정수형으로 자동 설정된다.    

<img width="1083" alt="1-6" src="https://user-images.githubusercontent.com/43739827/73833543-7a508380-484d-11ea-8cf4-5274e6d51dca.png"></img>  
> 행과 열에 0부터 시작하는 정수가 라벨링되어진것을 확인할 수 있다.

데이터 프레임의 열(Column)의 레이블이 0으로 되어있기에 검색조건을 ** Df[0] ** 으로하면 출력결과가 시리즈인 것을 확인할 수 있다. 이것은 데이터프레임은 2차원으로 구성되어있기 때문에 1차원 낮은 시리즈로 검색된 것이다.

<img width="1082" alt="1-7" src="https://user-images.githubusercontent.com/43739827/73834205-a6203900-484e-11ea-8a04-7d431c80abd6.png"></img>  
> 데이터 프레임의 검색기준은 항상 열이다. 슬라이싱은 행을 기준으로 하기 때문에 두가지에 대해서 확실하게 ] 알 필요가 있다.  

데이터 프레임을 검색하면 name이라는것이 함께 출력되는 것을 확인할 수 있다. name은 조회하는 열의 레이블을 나타내며 만약 데이터 프레임을 생성했을때 레이블을 설정했었다면 그 레이블을 검색 조건으로 지정해야 한다. 만약 레이블로 지정되지 않은 값을 검색조건으로 했을 때엔 ** KeyError ** 가 발생하게 된다.

<img width="1084" alt="1-9" src="https://user-images.githubusercontent.com/43739827/73835258-72461300-4850-11ea-8faa-2b1d22089256.png"></img>  


행을 검색하기 위해서는 iloc 인덱서를 사용한다. 실제 데이터 프레임의 행의 레이블은 순서와 상관없이 생성해도 되므로 실제 레이블을 검색하는 .loc 속성과 암묵적인 인덱스로 검색하는 .iloc 두 가지를 제공한다.  
행을 기준으로 검색하기 위해서는 **.loc** 혹은 **.iloc** 을 사용해야 한다. 두 함수의 차이는 loc은 인덱스를 기준으로 행을 읽어들이지만 iloc은 실제 행 번호를 기준으로 읽어들인다는 것이다.  

<img width="1087" alt="1-10" src="https://user-images.githubusercontent.com/43739827/73835848-7b83af80-4851-11ea-96a0-75584e4e0815.png"></img>
> .loc은 인덱스를 기준으로 데이터를 읽어들이기 때문에 행 번호나 인덱스가 아닌 값을 입력하면 오류가 발생한다.

<img width="1085" alt="1-11" src="https://user-images.githubusercontent.com/43739827/73836050-cef5fd80-4851-11ea-8aa1-f1fbbb6d3c03.png"></img>  
> .iloc은 행 번호를 기준으로 하기 때문에 데이터 프레임의 가장 마지막 행을 검색하고자 한다면 파이썬의 리스트처럼 [-1]을 해주면 된다.  

행 단위의 검색 또한 열 단위 검색과 마찬가지로 시리즈가 반환되는것을 확인할 수 있다. 만약 차원을 축소하여 데이터를 검색하고자 한다면 .iloc 함수에 특정 행과 열을 입력한다. 혹은 파이썬의 리스트와 마찬가지로 행,열을 연속으로 호출해도 동일한 결과를 보여준다.

<img width="1084" alt="1-12" src="https://user-images.githubusercontent.com/43739827/73836512-c651f700-4852-11ea-8639-0eb05d0124d7.png"></img>
> .iloc 함수를 사용하지 않은 일반적인 호출을 할 때엔 검색기준이 ['열(Column) 조건']['행(Row) 조건']임을 명심한다.   

* 데이터 구조의 편리성

판다스의 Series나 데이터 프레임 클래스는 다양한 속성이 있고 다양한 클래스의 객체를 이용한 구조로 이루어져 있다. 실제로 이 속성을 이용해 직접 접근도 가능하며, 다른 메소드를 사용해 내부적으로 접근을 하여 원하는 형태로 결과물을 출력하는 것도 가능하다.

* 행과 열에 대한 인덱스 정보 관리

판다스의 클래스에 대한 내부 정보에 접근할 수 있는 인덱스는 별도의 클래스이다. 이 인덱스는 내부 정보를 별도로 관리하면서 정보를 연결해 특정 원소 값과 부분 집합을 처리할 수 있는 구조를 구성한다. 데이터 처리는 numpy의 클래스로 처리하므로 numpy 모듈과의 연계성을 그대로 유지한다.  

하나의 데이터 프레임을 만들 때에는 행(index)과 열(column) 등 기본으로 3개의 매개변수가 있고 이것들을 전부 인자로 전달한다.  

<img width="804" alt="8" src="https://user-images.githubusercontent.com/43739827/73645185-2cefdd00-46ba-11ea-82f9-49f58ea9e023.png"></img>  

데이터 프레임의 생성 결과를 확인하면 행의 레이블과 열의 레이블이 지정되고, 내부 데이터 원소들의 값이 data로 전달된 값에 들어간 것을 볼 수 있다.  

<img width="361" alt="9" src="https://user-images.githubusercontent.com/43739827/73645429-a1c31700-46ba-11ea-8bb4-00e0a17eaeea.png"></img>

레이블을 관리하는 속성은 index 클래스의 인스턴스이고 데이터를 관리하는 속성은 numpy의 ndarray라는 것을 확인할 수 있다.  

<img width="375" alt="10" src="https://user-images.githubusercontent.com/43739827/73645623-febecd00-46ba-11ea-8565-7fe38bd2a838.png"></img>  

인덱서 .loc, .iloc 속성의 자료형을 type 클래스로 확인하면 두 개의 다른 클래스가 나오는 것을 볼 수 있다. type 클래스는 데이터 프레임등 판다스 클래스의 속성을 다양한 클래스로 내부의 정보를 사람들이 사용하기 편하게 보여줄 수 있는 기능을 제공한다.

* 인스턴스 관리 기준

판다스 모듈은 파이썬에서 클래스로 인스턴스를 만드는 것과 같다. 그러나 실제 연산을 처리할 때는 파이썬과 달리 내부의 원소를 갱신하는 것이 아닌 새로운 인스턴스를 만든다.  

필요한 경우에는 기존 인스턴스 내부를 갱신하기 위해 메소드 내부의 인스턴스에 지정해서 처리해야 한다. 판다스에 이런 기준이 있는 이유는 대용량 처리를 하기 위해서는 기존 인스턴스 내부를 갱신하기보다 새롭게 만들어서 처리하는 것이 더 빠르기 때문이다.  

또한 하나의 인스턴스를 다른 변수에 할당을 할 경우에도 기존 인스턴스의 레퍼런스를 공유해 처리하는 구조이다. 이를 별칭(alias)이라 하고, 실제 새로운 사본을 만들고자 한다면 copy 메소드를 사용해 다른 인스턴스를 생성하라는 것을 명확히 표시해야 한다.  

* 변수를 할당할 경우 항상 별칭으로 사용  
데이터 프레임을 하나 만들고 변수에 할당하여 그 내부의 값을 변경하면 원본에 있는 데이터를 갱신한다. 따라서 사본을 만들어서 사용하지 않으면 항상 원본도 같이 수정되므로 조심해야 한다.  

하나의 데이터 프레임을 만들 때 3행 3열인 총 9개 원소를 가지고 각 열의 이름을 a, b, c로 지정해 생성한 뒤 변수 df에 할당한다.

<img width="532" alt="11" src="https://user-images.githubusercontent.com/43739827/73646340-95d85480-46bc-11ea-8fac-ad71f68fcd5d.png"></img>  

새롭게 할당된 변수 df_a를 이용해 선택 연산자([])에 100이라는 값을 할당해서 갱신하였다. 실제 인덱스 연산자를 왼쪽에 넣고 할당 연산자 다음에 값을 넣어 데이터 프레임의 내부의 값을 변경하였다. 이 df_a를 확인하면 열 a 내의 원소들이 전부 100으로 바뀐것을 볼 수 있다.

<img width="194" alt="12" src="https://user-images.githubusercontent.com/43739827/73646597-2151e580-46bd-11ea-8292-f16828fb60f3.png"></img>  

최초에 만든 df 변수에 할당된 데이터 프레임을 확인해보면 열 a의 값이 변수 df_a 안의 a열의 값과 똑같이 변경된 것을 알 수 있다.  

두 개의 변수에 실제 값을 관리하는 속성인 values 안의 base 속성을 확인해보면 두 개의 레퍼런스가 같은것을 알 수 있다. 할당이란 별도로 사본을 만드는것이 아닌 원본을 참조하는 것이기 때문에 마치 데이터베이스의 CASCADE처럼 값을 수정하면 똑같이 변경되는것을 확인할 수 있다.  

<img width="383" alt="13" src="https://user-images.githubusercontent.com/43739827/73646907-bfde4680-46bd-11ea-9fee-38fbabe5da4c.png"></img>  

* 연산된 결과는 항상 새로운 인스턴스로 생성  
선택 연산자를 사용한 경우에는 기존 객체의 값을 바꿨지만, 다른 연산자나 메소드등은 대부분 연산을 수행할 때는 기존 원본은 변경하지 않고 새로운 사본을 만든다.  

연산된 결과는 대부분 같은 차원의 구조를 반환하지만, 가끔 차원이 축소된 결과를 반환하기도 한다.

<img width="236" alt="14" src="https://user-images.githubusercontent.com/43739827/73647361-a4c00680-46be-11ea-8316-d7f2399eed69.png">

위에서 생성된 df_a 변수에 있는 데이터 프레임을 가지고 특정 값 99를 덧셈으로 연산하여 다른 변수 df_b에 할당하였다. df_b를 빈 셀에 넣고 실행하면 실제 값이 변경된 것을 알 수 있다.  

<img width="381" alt="스크린샷 2020-02-03 오후 7 55 19" src="https://user-images.githubusercontent.com/43739827/73647571-21eb7b80-46bf-11ea-89c2-ce9f95df38c9.png"></img>  

변수 df_b와 df의 values 속성 안 base를 비교하면 False로 나온다. 이러한 이유는 덧셈 연산 등 대부분 판다스에서 제공하는 연산은 새로운 사본을 만들어 결과를 제공하므로, 변수에 할당하면 새로운 객체가 저장되기 때문이다. 몇 가지 예외가 있으나 주로 인덱스 연산자를 통한 할당은 기존 객체에 값을 변경하거나 열을 추가하는 것으로 이루어진다.  

실제 df 변수의 값을 확인하면 연산 결과와 상관 없이 원래 원소들이 그대로 유지된 것을 볼 수 있다.

Series와 데이터 프레임이 똑같이 처리되는지 확인하고자 한다. 먼저 numpy를 import하고 Series의 data를 arrange 함수로 4개의 원소를 만든다. index 매개변수에 a,b,c,d 4개의 이름을 부여해 원소를 생성한다.

<img width="526" alt="16" src="https://user-images.githubusercontent.com/43739827/73647995-f9b04c80-46bf-11ea-80b1-3da4ae6ef199.png"></img>  

새로운 s2 변수에 Series가 할당된 s1을 할당한 후에 두 개의 레퍼런스를 확인하면 두 개의 변수에 저장된 변수의 레퍼런스가 같은것을 확인할 수 있다.

<img width="215" alt="17" src="https://user-images.githubusercontent.com/43739827/73648149-41cf6f00-46c0-11ea-916a-79e8e2888cc0.png"></img>

다른 변수 s3에 s1 내부의 .copy 메소드를 이용해 할당한 후에 변수에 저장된 시리즈의 래퍼런스를 비교하면 두 개의 레퍼런스가 다른 것을 확인할 수 있다.

* 인덱스 검색과 슬라이싱 처리  
판다스에서의 인덱스 검색과 슬라이싱은 대괄호연산 및 마스킹(masking) 검색, 팬시(fancy) 검색 등이 추가되었다. 또한 속성인 인덱서(indexer)라는 개념도 추가되어 행 중심으로 검색하는 기능도 지원한다. 어떤 경우라도 대괄호 연산을 이용하려면 실제 '__getitem__' 스페셜 메소드가 수형되어 있어야 한다.

<img width="677" alt="18" src="https://user-images.githubusercontent.com/43739827/73648465-f5d0fa00-46c0-11ea-8cf4-70d5594bea71.png"></img>

판다스에서는 파이썬처럼 클래스의 인스턴스 메소드가 함수로 유지되는 것을 알 수 있다. 그리고 실제 인스턴스 개체와 메소드가 바인딩되면 메소드로 실행되는 것도 볼 수 있다.

<img width="893" alt="19" src="https://user-images.githubusercontent.com/43739827/73648812-b0f99300-46c1-11ea-96e4-de0b7dee2c86.png"></img>  

데이터 프레임을 만들고 인덱스를 검색하면 파이썬은 행 단위 처리를 기준으로 하지만 판다스의 데이터 프레임은 열 단위를 기준으로 처리하는 것을 볼 수 있다.  

<img width="312" alt="20" src="https://user-images.githubusercontent.com/43739827/73649406-10a46e00-46c3-11ea-86ee-f4bb335c4f95.png"></img>

실제 스페셜 메소드(__getitem__)에 직접 인자를 넣고 처리해도 잘 실행된다면 연산자를 이용해 실행하거나 스페셜 메소드를 직접 실행해도 같은 결과가 나오는 것을 알 수 있다. 즉, 실제 연산자는 모두 스페셜 메소드를 변환해 작동되는 것임을 알 수 있다.  

<img width="288" alt="21" src="https://user-images.githubusercontent.com/43739827/73649578-6b3dca00-46c3-11ea-9a64-3cccdbd503e7.png"></img>

데이터 프레임의 한 열을 다른 변수에 저장하면 하나의 Series가 만들어지는 것을 알 수 있다. 이 Series의 인덱스 검색 연산자와 스페셜 메소드를 가지고 처리하는 결과가 같음을 알 수 있다.  

<img width="341" alt="22" src="https://user-images.githubusercontent.com/43739827/73649724-c53e8f80-46c3-11ea-8c12-2a0d7e1688ae.png"></img>  

파이썬에서는 하나의 키 값이 인덱스 번호를 기반으로 한다. 반면 판다스는 Series와 데이터 프레임의 테이블 이름으로 인덱스 검색이 가능하다. 실제 논리식이 계산된 결과인 Series나 데이터 프레임을 가지고 인덱스 검색에서 사용하는 것도 가능하다.  

특정 원소들의 값이 True일 때는 가져오지만 False일 때는 가져오지 않고 없는 값으로 처리하기 위해 NaN으로 처리되면 정수 자료형도 실수 자료형으로 자동으로 변환이 되는것을 알 수 있다.  

## 3. 메소드 & 함수

판다스는 다양한 함수와 메소드를 제공한다. 대량의 데이터를 처리하기 위해서 순환문 없이 처리하는 기준을 수용했기 때문에 모양이나 차원이 다른 경우는 먼저 브로드캐스팅을 해서 모양을 맞춘 후에 내부의 원소를 계산한다. 또한 없는 데이턱가 발생해도 내부적으로 예외를 발생시키지 않고 데이터를 처리하면 차원별로 계산이 가능하다.  

판다스에서는 다양한 파일을 읽어와 데이터 프레임을 만들 수도 있지만 한글 등 문자열 데이터에 대한 변환인 인코딩또한 필요하다.  

* 브로드캐스팅 및 벡터와 연산

판다스에 있는 Series나 데이터 프레임은 여러 원소를 가진 다차원 데이터이므로 이 원소를 순환문을 이용해 처리하기보다 내부적으로 각 원소별로 처리하는 것이 더 편하다.

여러 원소를 가진 Series나 데이터 프레임의 원소의 개수를 맞추는 것을 브로드캐스팅이라하고 이를 한 번에 연산 처리하는 것을 벡터화 연산(vectorizing)이라고 한다.  

Series나 데이터 프레임은 여러 차원으로 구성된 데이터이므로 이를 계산할 경우 각 원소들의 개수를 차원 단위로 맞추어야 한다. 이를 자동으로 맞춘 후에 연산을 처리하므로 실제 차원이 다르다면 차원을 맞추는 일을 먼저 수행한 후에 연산을 처리한다.  
각 원소별로 계산할 때 브로드캐스팅 후에 순환을 수동으로 처리하지 않고 자동으로 처리되는 벡터화 연산을 수행해 모든 원소를 계산하도록 처리한다.

<img width="650" alt="23" src="https://user-images.githubusercontent.com/43739827/73650430-86113e00-46c5-11ea-82e2-05387d162a3f.png"></img>  

데이터 프레임을 만들 때 내부의 원소가 9개다. 이 차원을 3행 3열로 구성한다. 열의 레이블 이름을 문자열로 주고 이를 list로 생성하면 각 열의 이름이 a, b, c로 구성되는 것을 알 수 있다. 행의 레이블은 지정하지 않았으므로 내부적으로 일련의 숫자로 처리되는 것을 볼 수 있다.  

<img width="639" alt="24" src="https://user-images.githubusercontent.com/43739827/73650582-d7213200-46c5-11ea-8165-3eb82b6abf74.png"></img>  

같은 값으로 9개의 원소를 가진 것을 3개씩 3개의 행(3 X 3)을 가지는 리스트로 넣고 열의 이름을 columns에 넣어 데이터 프레임을 만든 뒤 df1이라는 변수에 할당했다.

<img width="201" alt="25" src="https://user-images.githubusercontent.com/43739827/73650676-0a63c100-46c6-11ea-8b0c-6ed213e98118.png"></img>  

변수 df에 할당된 데이터 프레임에 상수 값 3을 더하면 실제 상수 3이 3행3열의 데이터 프레임으로 바뀌는 브로드캐스팅 처리가 되고 + 연산자로 각 원소별로 계산이 된다. 기존 데이터 프레임의 각 원소에 3씩 증가된 것을 볼 수 있다.

<img width="191" alt="26" src="https://user-images.githubusercontent.com/43739827/73650776-46972180-46c6-11ea-81f4-889b82d01f2b.png"></img>  

두 개의 변수 df, df1 데이터 프레임에 + 연산자로 더했을 경우 위의 결과와 같은 것을 알 수 있다. 이 연산을 확인하면 실제 순환문이 없이 내부적으로 9개의 원소들끼리의 덧셈 연산이 처리되었는데, 이런 처리를 벡터화 연산이라 한다.  

<img width="314" alt="27" src="https://user-images.githubusercontent.com/43739827/73650855-7f36fb00-46c6-11ea-8d95-a735ffa00e2c.png"></img>

파이썬의 덧셈 연산은 내부적인 __add__ 스페셜 메소드로 제공한다. 이 연산자 내부의 함수를 __func__ 에 확인하면 실제 함수가 들어 있는 것을 알 수 있다.  

파이썬은 내부적으로 method라는 클래스가 만드는 메소드가 있고 그 메소드 내부에는 실제 수행하는 함수가 존재한다.  

<img width="269" alt="28" src="https://user-images.githubusercontent.com/43739827/73650982-c4f3c380-46c6-11ea-9cef-95137d3f2559.png"></img>

판다스에서는 데이터 프레임 안의 연산자 말고도 add라는 메소드도 별도로 제공한다. 이 add라는 메소드는 스페셜 메소드와 동일하게 method 클래스에 만들어진 것을 알 수 있다. 메소드 내부에 __func__ 을 보면 함수가 저장되었다.

판다스에서 스페셜 메소드와 메소드를 이중으로 제공하는 이유는 실제 연산자 연산 말고도 다양한 매개변수를 메소드에 넣어 기능을 확장 처리할 수 있도록 하기 위함이다.  

<img width="336" alt="29" src="https://user-images.githubusercontent.com/43739827/73651122-1c922f00-46c7-11ea-9405-941f91ed3533.png"></img>  

스페셜 메소드와 메소드 안의 함수가 같은지를 비교해보면 서로 다른 함수가 저장된 것을 알 수 있다. 실제 매개변수 차이로 두 개의 함수가 별도로 만들어져 __func__ 에 할당하고 처리하게 된다.

* 누락 값을 포함한 데이터 처리  
판다스 클래스들의 특징은 실제 원소의 값이 들어가 있지 않아도 예외가 없이 처리된다는 것이다. 판다스 모듈에 있는 대부분의 클래스는 대용량 데이터를 처리할 때 누락 값(missing)이 있어도 예외를 발생시키지 않고 처리한다.  

판다스에서는 누락값을 표시하는 방법으로 NaN을 사용한다. 이 값은 일반적으로 numpy 모듈에서의 np.nan을 의미한다.  

누락 값 연산을 처리할 때 수학 메소드들은 실제 값들이 있을 때만 계산을 수행하고 아닌 경우를 NaN으로 처리한다. 이 NaN값은 논리식으로 비교하면 항상 False 처리가 된다.

<img width="393" alt="30" src="https://user-images.githubusercontent.com/43739827/73730927-f7f78f00-477a-11ea-886e-2d2179da0d58.png"></img>  

데이터 프레임 생성자를 이용해 인스턴스를 만들 때 두 개의 원소는 정수를 넣고 나머지 원소는 누락 값인 np.nan을 처리해 생성한다.  

누락 값인 NaN은 판다스에서는 float로 지정해 관리하므로 생성된 자료의 데이터 자료형도 float64가 된다.  

<img width="286" alt="31" src="https://user-images.githubusercontent.com/43739827/73731482-e793e400-477b-11ea-95bb-803aa869a51d.png"></img>  

데이터 프레임 내부의 .sum 메소드를 실행하면 모든 원소를 더하고 더한 값을 반환한다. 반환된 값은 1차원 Series로 만들어지는데, .sum 메소드는 계산결과를 한 차원 축소한 결과를 반환한다.  

누락 값은 계산을 하지 않고 숫자만 계산해 반환한다. .sum 메소드에서 모든 원소를 전부 계산하고 싶을 때는 매개변수 skipna=True로 지정하면 누락 값을 포함해 계산한다. 그리고 그 결과는 NaN으로 처리도니다. 모든 NaN 값과 계산된 결과는 NaN으로 처리된다.

<img width="244" alt="32" src="https://user-images.githubusercontent.com/43739827/73731728-56713d00-477c-11ea-99f3-a58afa03a691.png"></img>  

비교 연산자를 사용하면 True와 False로 결과 값을 제공한다. 누락 값과의 비교는 항상 False로 처리된다.

<img width="211" alt="33" src="https://user-images.githubusercontent.com/43739827/73731844-87517200-477c-11ea-98a3-ecfa2538f2a3.png"></img>  

누락 값인 np.nan을 이용해 비교 연산자를 사용하면 같은 누락 값에 대해서도 False로 표시한다. 즉, 누락 값은 비교 연산에 사용할 수 없다는 표시이다.

## 4.축
판다스는 다차원 계산을 처리하므로 실제 각 차원에 대한 축을 기준으로 계산한다. 따라서 축을 이용해 데이터의 원소를 연결하기 위해 축(axis)이 무엇인지 이해해야 한다.  

판다스에서는 클래스의 1차원인 Series와 2차원인 데이터 프레임을 생성한 후에 다양한 메소드를 지원하고 매개변수 axis에 각 축에 대한 정보를 0, 1로 지정해 각 축을 기준으로 처리한다.  

검색이나 병합 등 다양한 함수나 메소드를 처리할 대도 축을 기준으로 연결하므로 축에 대해 정확히 이해할 필요가 있다.

* 축  
다차원 배열을 처리할 때 1차원인 Series는 축이 하나만 존재하므로 기본으로 0만을 사용하며 2차원인 데이터 프레임은 0인 행과 1인 열로 만들어진다. 보통 축은 1차원일 때 0(index)만 있고 2차원일 때 0인 행과 1인 열을 가진다면, 판다스에서는 축에 대한 정보를 일관성있게 처리한다.  

축은 열과 행을 처리하는 다양한 메소드에서 사용하고 실제 내부의 원소들을 계산할 때에도 사용된다. 원소들을 계산할 때는 0축은 각 열에 대한 행의 원소들을 계산하도록 하고 1축은 각 행에 대한 열의 원소들을 계산한다.  

<img width="641" alt="34" src="https://user-images.githubusercontent.com/43739827/73732730-072c0c00-477e-11ea-8c30-6a421d0c1dd1.png"></img>  

행과 열은 각각 axis=0과 axis=1을 의미한다. 계산할 때는 axis를 주고 그 축에 대한 고정을 지정하면, 고정된 축을 기준으로 내부의 값들이 계산된다.  

<img width="344" alt="35" src="https://user-images.githubusercontent.com/43739827/73733175-d3051b00-477e-11ea-91c5-cfc157c91c42.png"></img>  

4개의 원소를 갖는 하나의 Series를 만들 때 행에 대한 레이블인 index 매개변수에 인자를 넣지 않고 생성한다. Series는 1차원이므로 0번 축인 열을 기준으로 만들어지게 된다.  

축을 고정해서 계산한다는 것은 행을 고정해서 계산하라는 뜻이다. Series는 기본적으로 행에 대한 계산을 하기 때문이다.

<img width="282" alt="36" src="https://user-images.githubusercontent.com/43739827/73733334-224b4b80-477f-11ea-9ac8-a4e1b993adc0.png"></img>  

따라서 Series의 객체에 있는 .sum 메소드에 axis=0을 입력하면 행을 고정해서 그 내부의 원소를 계산하라는 뜻이다. 결과는 모든 원소를 더한 값이 정수로 출력된다.  

<img width="893" alt="37" src="https://user-images.githubusercontent.com/43739827/73733707-c9c87e00-477f-11ea-8539-738db515ff3d.png"></img>  

2행 4열의 리스트를 넣어 데이터 프레임을 만들었다. 행과 열에 대한 정보를 할당하지 않아서 내부적으로 숫자로 행과 열의 레이블이 자동으로 입력된 것을 확인할 수 있다.  

<img width="885" alt="38" src="https://user-images.githubusercontent.com/43739827/73733851-072d0b80-4780-11ea-85a9-5eedde44423a.png"></img>  

.sum 메소드를 가지고 데이터 프레임의 axis=0을 전달하는 것은 열 단위로 계산을 하라는 뜻이다. 반대로 생각해보면 열을 기준으로 고정했기 때문에 열이 레이블에 고정되어 있어 계산된 결과 값이 열 단위로 남아있다.  

<img width="888" alt="39" src="https://user-images.githubusercontent.com/43739827/73734050-5ecb7700-4780-11ea-8c30-f190ed8be779.png"></img>  

axis=1을 지정하면 행을 고정하고 열의 모든 원소를 전부 계산하라는 뜻이다. 이 데이터 프레임은 2행 4열이므로 두 개의 행을 기준으로 열의 합산을 계산해서 결과를 내는 것을 알 수 있다.  

* 수학 연산 시 처리 규칙  
데이터 프레임 객체에 연산을 하면 단항(Unary) 연산자는 주로 하나의 객체를 처리하므로 내부에 지정된 행과 열에 대한 레이블을 유지하지만 이항(binary) 연산자는 두 개의 객체를 처리하므로 행과 열의 레이블을 정렬(alignment)해서 비교한 후에 계산하므로 레이블이 정렬되어 처리된다.  

* 내부 원소에 대한 정렬  
데이터 프레임을 만들 때 수학 연산이 발생하는 경우 단항 연산자와 이항 연산자들이 처리되는 결과를 확인한다.  

<img width="1086" alt="40" src="https://user-images.githubusercontent.com/43739827/73735284-61c76700-4782-11ea-9551-e6895cee596c.png"></img>  

numpy 모듈을 이용하여 1부터 10까지의 숫자를 가지고 3행 3열의 배열을 만들고 데이터 프레임으로 정의한다. 행의 레이블은 암묵적으로 처리되도록 지정하지 않았고, 열의 레이블을 A, B, C로 부여한다. 처리 결과를 보면 데이터 프레임도 3행 3열로 구성되고 행과 열의 레이블이 표시된 것을 알 수 있다.  

<img width="1086" alt="41" src="https://user-images.githubusercontent.com/43739827/73735820-309b6680-4783-11ea-8fcd-f07e334e0185.png"></img>  

<img width="1084" alt="42" src="https://user-images.githubusercontent.com/43739827/73736026-7b1ce300-4783-11ea-98f0-f2ba75ec4134.png"></img>  

또 다른 데이터 프레임 객체를 만들었다. numpy의 log 함수를 이용해서 데이터 프레임을 계산하면 현재 정의된 레이블은 유지되면서 계산된 결과에 새로운 데이터 프레임 객체를 반환한다.  

<img width="1086" alt="43" src="https://user-images.githubusercontent.com/43739827/73736488-2ded4100-4784-11ea-9b29-49b66fafd2a2.png"></img>  

두 개의 데이터 프레임에 덧셈 연산인 즉 이항 연산자의 연산을 하면 행과 열의 레이블을 맞춰 정렬하여 계산한 후에 정렬된 데이터 프레임 객체를 반환한다.  

<img width="1085" alt="44" src="https://user-images.githubusercontent.com/43739827/73736684-8fadab00-4784-11ea-8452-94ce840943e1.png"></img>  

<img width="1082" alt="45" src="https://user-images.githubusercontent.com/43739827/73736785-c1bf0d00-4784-11ea-9dae-20d97458efaf.png"></img>  

이번에는 두 개의 열만을 갖는 데이터 프레임을 생성한다. 이를 이전에 만들어진 df_1 데이터 프레임과 연산하면 정렬을 처리해서, 만들어질 때 없었던 A열의 값이 NaN으로 처리된다. 이때 NaN으로 계산되는 결과는 항상 NaN이므로 A열의 값이 전부 NaN으로 처리되는 것을 알 수 있다.  

* 파일 처리 및 한글 인코딩  
판다스에서는 다양한 파일을 읽어서 데이터 프레임으로 변환하는 일이 많다. 특히 csv 파일을 읽어서 데이터 프레임으로 바로 변환하여 처리하는 방법이 아주 편하게 사용되기도 한다. 파일 안의 문자열이 한글일 때 파이썬은 utf-8로 인코딩을 처리한 후에 데이터 프레임으로 전환해야 한다.

한글을 사용하는 경우에는 완성형과 조합형으로 되어 있을 때가 많다. 이중에 완성형에서는 각 솔루션별로 다른 인코딩을 사용하므로 한글 인코딩도 작성된 솔루션에 맞춰 처리해야 한다.

파일을 읽고 그 파일이 어떤 형태로 한글 인코딩되는지를 알아볼 필요가 있다. 이때 다른 파이썬 모듈인 chardet 모듈을 추가 설치해주어야 한다.  

<img width="890" alt="46" src="https://user-images.githubusercontent.com/43739827/73739334-5deb1300-4789-11ea-8f5d-570b804d4700.png"></img>

이 모듈이 설치된 후에 import하고 읽어온 파일을 열어 이 파일이 어떤 인코딩으로 처리되는지를 확인한다. detect 메소드로 이 파일의 정보를 읽은 후 result 변수에 'encoding'속성을 확인해 인코딩 방식을 조회할 수 있다.  

판다스 모듈의 .read_csv 함수에 하나의 csv 파일에 있는 path를 넣고 open 한다. encoding 매개변수에 find_encoding 함수에서 실행된 결과인 인코딩 정보를 가져와서 실행하면 데이터 프레임이 하나 만들어진다. 그리고 실제 인코딩한 정보를 저장한 my_encoding 변수를 출력하면 인코딩 정보가 출력되는것을 확인할 수 있다. 인코딩으로 들어올 매개변수가 다를 경우 예외도 발생할 수 있다.  

<img width="892" alt="47" src="https://user-images.githubusercontent.com/43739827/73739634-fb464700-4789-11ea-8283-34c2f1ddd10b.png"></img>  

이 파일은 읽어온 것을 df_1 변수에 할당했으므로 이중에 앞에 있는 것을 head 메소드로 조회하면 이 데이터 프레임에 위의 5개까지 출력하는 것을 볼 수 있다. 이 파일은 열 이름은 한글이고 내부의 데이터도 한글로 처리된 것을 확인 할 수 있다. 이 파일은 열 이름은 한글이고 내부의 데이터도 한글로 처리된 것을 확인 가능하다.  

<img width="884" alt="48" src="https://user-images.githubusercontent.com/43739827/73740179-077ed400-478b-11ea-886e-1ee44a0eed59.png"></img>  

head에 특정 값을 입력하면 맨 위 행에서 특정값을 위치로하는 행까지 보여준다.  

<img width="885" alt="49" src="https://user-images.githubusercontent.com/43739827/73740640-e36fc280-478b-11ea-98a2-a927f82be885.png"></img>  

특정 열의 삭제하고 싶다면 .drop메소드에 그 열의 이름과 axis=1을 입력하면 삭제할 수 있다.
